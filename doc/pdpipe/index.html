<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdpipe API documentation</title>
<meta name="description" content="The `pdpipe` Python package provides a concise interface for building `pandas`
pipelines that have pre-conditions, are verbose, support the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pdpipe</code></h1>
</header>
<section id="section-intro">
<p>The <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code> Python package provides a concise interface for building <code>pandas</code>
pipelines that have pre-conditions, are verbose, support the fit-transform
design of scikit-learn transformers and are highly serializable. <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code>
pipelines have a simple interface, informative prints and errors on pipeline
application, support pipeline arithmetics and enable easier handling of
mixed-type data.</p>
<h1 id="features">Features</h1>
<ul>
<li>A simple interface.</li>
<li>Informative prints and errors on pipeline application.</li>
<li>Chaining pipeline stages constructor calls for easy, one-liners pipelines.</li>
<li>Pipeline arithmetics.</li>
<li>Easier handling of mixed data (numeric, categorical and others).</li>
<li><a href="https://travis-ci.org/pdpipe/pdpipe&gt;">Fully tested on Linux, macOS and Windows systems</a>.</li>
<li>Compatible with Python 3.5+.</li>
<li>Pure Python.</li>
</ul>
<h2 id="design-decisions">Design Decisions</h2>
<ul>
<li><strong>Extra infromative naming:</strong> Meant to make pipelines very readable, understanding their entire flow by pipeline stages names; e.g. ColDrop vs. ValDrop instead of an all-encompassing Drop stage emulating the <code>pandas.DataFrame.drop</code> method.</li>
<li><strong>Data science-oriented naming</strong> (rather than statistics).</li>
<li><strong>A functional approach:</strong> Pipelines never change input DataFrames. Nothing is done "in place".</li>
<li><strong>Opinionated operations:</strong> Help novices avoid mistake by default appliance of good practices; e.g., one-hot-encoding (creating dummy variables) a column will drop one of the resulting columns by default, to avoid <a href="http://www.algosome.com/articles/dummy-variable-trap-regression.html">the dummy variable trap</a> (perfect <a href="https://en.wikipedia.org/wiki/Multicollinearity">multicollinearity</a>).</li>
<li><strong>Machine learning-oriented:</strong> The target use case is transforming tabular data into a vectorized dataset on which a machine learning model will be trained; e.g., column transformations will drop the source columns to avoid strong linear dependence.</li>
</ul>
<h1 id="installation">Installation</h1>
<p>Install <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code> with:</p>
<pre><code class="language-python">  pip install pdpipe
</code></pre>
<p>Some pipeline stages require <code>scikit-learn</code>; they will simply not be loaded if <code>scikit-learn</code> is not found on the system, and <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code> will issue a warning. To use them you must also <a href="http://scikit-learn.org/stable/install.html">install scikit-learn</a>.</p>
<p>Similarly, some pipeline stages require <code>nltk</code>; they will not be loaded if <code>nltk</code> is not found on your system, and <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code> will issue a warning. To use them you must additionally <a href="http://www.nltk.org/install.html">install nltk</a>.</p>
<h1 id="basic-use">Basic Use</h1>
<p>The awesome Tirthajyoti Sarkar wrote <a href="https://tirthajyoti.github.io/Notebooks/Pandas-pipeline-with-pdpipe">an excellent practical introduction on how to use pdpipe</a>. Read it now <a href="https://tirthajyoti.github.io/Notebooks/Pandas-pipeline-with-pdpipe">on his website</a>!</p>
<p>For a thorough overview of all the capabilities of <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code>, continue below:</p>
<h2 id="pipeline-stages">Pipeline Stages</h2>
<h3 id="creating-pipeline-stages">Creating Pipeline Stages</h3>
<p>You can create stages with the following syntax:</p>
<pre><code class="language-python">  import pdpipe as pdp
  drop_name = pdp.ColDrop(&quot;Name&quot;)
</code></pre>
<p>All pipeline stages have a predefined precondition function that returns True for dataframes to which the stage can be applied. By default, pipeline stages raise an exception if a DataFrame not meeting their precondition is piped through. This behaviour can be set per-stage by assigning <code>exraise</code> with a bool in the constructor call. If <code>exraise</code> is set to <code>False</code> the input DataFrame is instead returned without change:</p>
<pre><code class="language-python">  drop_name = pdp.ColDrop(&quot;Name&quot;, exraise=False)
</code></pre>
<h3 id="applying-pipeline-stages">Applying Pipeline Stages</h3>
<p>You can apply a pipeline stage to a DataFrame using its <code>apply</code> method:</p>
<pre><code class="language-python">  res_df = pdp.ColDrop(&quot;Name&quot;).apply(df)
</code></pre>
<p>Pipeline stages are also callables, making the following syntax equivalent:</p>
<pre><code class="language-python">  drop_name = pdp.ColDrop(&quot;Name&quot;)
  res_df = drop_name(df)
</code></pre>
<p>The initialized exception behaviour of a pipeline stage can be overridden on a per-application basis:</p>
<pre><code class="language-python">  drop_name = pdp.ColDrop(&quot;Name&quot;, exraise=False)
  res_df = drop_name(df, exraise=True)
</code></pre>
<p>Additionally, to have an explanation message print after the precondition is checked but before the application of the pipeline stage, pass <code>verbose=True</code>:</p>
<pre><code class="language-python">  res_df = drop_name(df, verbose=True)
</code></pre>
<p>All pipeline stages also adhere to the <code>scikit-learn</code> transformer API, and so have <code>fit_transform</code> and <code>transform</code> methods; these behave exactly like <code>apply</code>, and accept the input dataframe as parameter <code>X</code>. For the same reason, pipeline stages also have a <code>fit</code> method, which applies them but returns the input dataframe unchanged.</p>
<h3 id="fittable-pipeline-stages">Fittable Pipeline Stages</h3>
<p>Some pipeline stages can be fitted, meaning that some transformation parameters are set the first time a dataframe is piped through the stage, while later applications of the stage use these now-set parameters without changing them; the <code>Encode</code> scikit-learn-dependent stage is a good example.</p>
<p>For these type of stages the first call to <code>apply</code> will both fit the stage and transform the input dataframe, while subsequent calls to <code>apply</code> will transform input dataframes according to the already-fitted transformation parameters.</p>
<p>Additionally, for fittable stages the <code>scikit-learn</code> transformer API methods behave as expected:</p>
<ul>
<li><code>fit</code> sets the transformation parameters of the stage but returns the input dataframe unchanged.</li>
<li><code>fit_transform</code> both sets the transformation parameters of the stage and returns the input dataframe after transformation.</li>
<li><code>transform</code> transforms input dataframes according to already-fitted transformation parameters; if the stage is not fitted, an <code>UnfittedPipelineStageError</code> is raised.</li>
</ul>
<p>Again, <code>apply</code>, <code>fit_transform</code> and
are all of equivalent for non-fittable pipeline stages. And in all cases the <code>y</code> parameter of these methods is ignored.</p>
<h2 id="pipelines">Pipelines</h2>
<h3 id="creating-pipelines">Creating Pipelines</h3>
<p>Pipelines can be created by supplying a list of pipeline stages:</p>
<pre><code class="language-python">    pipeline = pdp.PdPipeline([pdp.ColDrop(&quot;Name&quot;), pdp.OneHotEncode(&quot;Label&quot;)]
</code></pre>
<p>Additionally, the
method can be used to give stages as positional arguments.</p>
<pre><code class="language-python">    pipeline = pdp.make_pdpipeline(pdp.ColDrop(&quot;Name&quot;), pdp.OneHotEncode(&quot;Label&quot;))
</code></pre>
<h3 id="printing-pipelines">Printing Pipelines</h3>
<p>A pipeline structre can be clearly displayed by printing the object:</p>
<pre><code class="language-python">  &gt;&gt;&gt; drop_name = pdp.ColDrop(&quot;Name&quot;)
  &gt;&gt;&gt; binar_label = pdp.OneHotEncode(&quot;Label&quot;)
  &gt;&gt;&gt; map_job = pdp.MapColVals(&quot;Job&quot;, {&quot;Part&quot;: True, &quot;Full&quot;:True, &quot;No&quot;: False})
  &gt;&gt;&gt; pipeline = pdp.PdPipeline([drop_name, binar_label, map_job])
  &gt;&gt;&gt; print(pipeline)
  A pdpipe pipeline:
  [ 0]  Drop column Name
  [ 1]  OneHotEncode Label
  [ 2]  Map values of column Job with {'Part': True, 'Full': True, 'No': False}.
</code></pre>
<h3 id="pipeline-arithmetics">Pipeline Arithmetics</h3>
<p>Alternatively, you can create pipelines by adding pipeline stages together:</p>
<pre><code class="language-python">  pipeline = pdp.ColDrop(&quot;Name&quot;) + pdp.OneHotEncode(&quot;Label&quot;)
</code></pre>
<p>Or even by adding pipelines together or pipelines to pipeline stages:</p>
<pre><code class="language-python">  pipeline = pdp.ColDrop(&quot;Name&quot;) + pdp.OneHotEncode(&quot;Label&quot;)
  pipeline += pdp.MapColVals(&quot;Job&quot;, {&quot;Part&quot;: True, &quot;Full&quot;:True, &quot;No&quot;: False})
  pipeline += pdp.PdPipeline([pdp.ColRename({&quot;Job&quot;: &quot;Employed&quot;})])
</code></pre>
<h3 id="pipeline-chaining">Pipeline Chaining</h3>
<p>Pipeline stages can also be chained to other stages to create pipelines:</p>
<pre><code class="language-python">  pipeline = pdp.ColDrop(&quot;Name&quot;).OneHotEncode(&quot;Label&quot;).ValDrop([-1], &quot;Children&quot;)
</code></pre>
<h3 id="pipeline-slicing">Pipeline Slicing</h3>
<p>Pipelines are Python Sequence objects, and as such can be sliced using Python's slicing notation, just like lists:</p>
<pre><code class="language-python">  &gt;&gt;&gt; pipeline = pdp.ColDrop(&quot;Name&quot;).OneHotEncode(&quot;Label&quot;).ValDrop([-1], &quot;Children&quot;).ApplyByCols(&quot;height&quot;, math.ceil)
  &gt;&gt;&gt; pipeline[0]
  Drop column Name
  &gt;&gt;&gt; pipeline[1:2]
  A pdpipe pipeline:
  [ 0] OneHotEncode Label
</code></pre>
<p>Pipelines can also be sliced by the stages <code>name</code> parameter, notice when running <code>pipeline[['name1', 'name2']]</code> a new pipeline will returned with all stages that they <code>name</code> is 'name1' or 'name2', and when running `pipeline['name'] only the first stage that has the 'name' will return.:</p>
<pre><code class="language-python">  &gt;&gt;&gt; pipeline = pdp.ColDrop(&quot;Name&quot;, name=&quot;dropName&quot;).OneHotEncode(&quot;Label&quot;, name=&quot;encoder&quot;).ValDrop([-1], &quot;Children&quot;).ApplyByCols(&quot;height&quot;, math.ceil)
  &gt;&gt;&gt; pipeline['dropName']
  PdPipelineStage: Drop columns Name
  &gt;&gt;&gt; pipeline[['dropName', 'encoder']]
  A pdpipe pipeline:
  [ 0]  Drop columns Name
  [ 1]  One-hot encode Label
</code></pre>
<h3 id="applying-pipelines">Applying Pipelines</h3>
<p>Pipelines are pipeline stages themselves, and can be applied to a DataFrame using the same syntax, applying each of the stages making them up, in order:</p>
<pre><code class="language-python">  pipeline = pdp.ColDrop(&quot;Name&quot;) + pdp.OneHotEncode(&quot;Label&quot;)
  res_df = pipeline(df)
</code></pre>
<p>Assigning the
parameter to a pipeline apply call with a bool sets or unsets exception raising on failed preconditions for all contained stages:</p>
<pre><code class="language-python">  pipeline = pdp.ColDrop(&quot;Name&quot;) + pdp.OneHotEncode(&quot;Label&quot;)
  res_df = pipeline.apply(df, exraise=False)
</code></pre>
<p>Additionally, passing <code>verbose=True</code> to a pipeline apply call will apply all pipeline stages verbosely:</p>
<pre><code class="language-python">  res_df = pipeline.apply(df, verbose=True)
</code></pre>
<p>Finally, <code>fit</code>, <code>transform</code> and <code>fit_transform</code> all call the corresponding pipeline stage methods of all stages composing the pipeline</p>
<h2 id="column-qualifiers">Column Qualifiers</h2>
<p>All <code><a title="pdpipe" href="#pdpipe">pdpipe</a></code> pipeline stages that posses the <code>columns</code> parameter can accept callables - instead of lists of labels - as valid arguments to that parameter. These callables are assumed to be column qualifiers - functions that can be applied to an input dataframe to extract the list of labels to operate on in run time.</p>
<p>The module <code><a title="pdpipe.cq" href="cq.html">pdpipe.cq</a></code> provides a powerful class - <code>ColumnQualifier</code> - implementing this idea with various enhancements, like the ability to fit a list of labels in fit time to be retained for future transforms and support for various boolean operators between column qualifiers.</p>
<p>It also provides ready implementations for qualifiers qualifying columns by label, dtype and the number of missing values. This enable powerful behaviours like dropping columns by missing value frequency, scaling only integer columns or performing PCA on the subset of columns starting with the string <code>'tfidf_token_'</code>.</p>
<p>Read more on column qualifiers in the documentation of the <code><a title="pdpipe.cq" href="cq.html">pdpipe.cq</a></code> module.</p>
<h1 id="types-of-pipeline-stages">Types of Pipeline Stages</h1>
<p>All built-in stages are thoroughly documented, including examples; if you find any documentation lacking please open an issue. A list of briefly described available built-in stages follows:</p>
<h2 id="basic-stages">Basic Stages</h2>
<ul>
<li>AdHocStage - Define custom pipeline stages on the fly.</li>
<li>ColDrop - Drop columns by name.</li>
<li>ValDrop - Drop rows by by their value in specific or all columns.</li>
<li>ValKeep - Keep rows by by their value in specific or all columns.</li>
<li>ColRename - Rename columns.</li>
<li>DropNa - Drop null values. Supports all parameter supported by pandas.dropna function. </li>
<li>FreqDrop - Drop rows by value frequency threshold on a specific column.</li>
<li>ColReorder - Reorder columns.</li>
<li>RowDrop - Drop rows by callable conditions.</li>
<li>Schematize - Learn a dataframe schema on fit and transform to it on future transforms.</li>
<li>DropDuplicates - Drop duplicate values in a subset of columns.</li>
</ul>
<h2 id="column-generation">Column Generation</h2>
<ul>
<li>Bin - Convert a continuous valued column to categoric data using binning.</li>
<li>OneHotEncode - Convert a categorical column to the several binary columns corresponding to it.</li>
<li>MapColVals - Replace column values by a map.</li>
<li>ApplyToRows - Generate columns by applying a function to each row.</li>
<li>ApplyByCols - Generate columns by applying an element-wise function to columns.</li>
<li>ColByFrameFunc - Add a column by applying a dataframe-wide function.</li>
<li>AggByCols - Generate columns by applying an series-wise function to columns.</li>
<li>Log - Log-transform numeric data, possibly shifting data before.</li>
</ul>
<h2 id="text-stages">Text Stages</h2>
<ul>
<li>RegexReplace - Replace regex occurences in columns of strings.</li>
<li>DropTokensByLength - Drop tokens in token lists by token length.</li>
<li>DropTokensByList - Drop every occurence of a given set of string tokens in token lists.</li>
</ul>
<h2 id="scikit-learn-dependent-stages">Scikit-learn-dependent Stages</h2>
<ul>
<li>Encode - Encode a categorical column to corresponding number values.</li>
<li>Scale - Scale data with any of the sklearn scalers.</li>
<li>TfidfVectorizeTokenLists - Transform a column of token lists into the correponding set of tfidf vector columns.</li>
</ul>
<h2 id="nltk-dependent-stages">nltk-dependent Stages</h2>
<ul>
<li>TokenizeWords - Tokenize a sentence into a list of tokens by whitespaces.</li>
<li>UntokenizeWords - Joins token lists into whitespace-seperated strings.</li>
<li>RemoveStopwords - Remove stopwords from a tokenized list.</li>
<li>SnowballStem - Stems tokens in a list using the Snowball stemmer.</li>
<li>DropRareTokens - Drop rare tokens from token lists.</li>
</ul>
<h1 id="creating-additional-stages">Creating additional stages</h1>
<h2 id="extending-pdpipelinestage">Extending Pdpipelinestage</h2>
<p>To use other stages than the built-in ones (see <a href="#types-of-pipeline-stages">Types of Pipeline Stages</a> you can extend the
class. The constructor must pass the <code>PdPipelineStage</code> constructor the <code>exmsg</code>, <code>appmsg</code> and <code>desc</code> keyword arguments to set the exception message, application message and description for the pipeline stage, respectively. Additionally, the <code>_prec</code> and <code>_transform</code> abstract methods must be implemented to define the precondition and the effect of the new pipeline stage, respectively.</p>
<p>Fittable custom pipeline stages should implement, additionally to the
method, the <code>_fit_transform</code> method, which should both fit pipeline stage by the input dataframe and transform transform the dataframe, while also setting <code>self.is_fitted = True</code>.</p>
<h2 id="ad-hoc-pipeline-stages">Ad-Hoc Pipeline Stages</h2>
<p>To create a custom pipeline stage without creating a proper new class, you can instantiate the
class which takes a function in its <code>transform</code> constructor parameter to define the stage's operation, and the optional <code>prec</code> parameter to define a precondition (an always-true function is the default).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The `pdpipe` Python package provides a concise interface for building `pandas`
pipelines that have pre-conditions, are verbose, support the fit-transform
design of scikit-learn transformers and are highly serializable. `pdpipe`
pipelines have a simple interface, informative prints and errors on pipeline
application, support pipeline arithmetics and enable easier handling of
mixed-type data.

.. include:: ./documentation.md
&#34;&#34;&#34;
# pylint: disable=C0413
# flake8: noqa

import warnings
import traceback


from . import core
from .core import PdPipelineStage, AdHocStage, PdPipeline, make_pdpipeline

core.__load_stage_attributes_from_module__(&#34;pdpipe.core&#34;)

from . import basic_stages
from .basic_stages import (
    ColDrop,
    ValDrop,
    ValKeep,
    ColRename,
    DropNa,
    SetIndex,
    FreqDrop,
    ColReorder,
    RowDrop,
    Schematize,
    DropDuplicates,
    ColumnDtypeEnforcer,
    ConditionValidator,
)

core.__load_stage_attributes_from_module__(&#34;pdpipe.basic_stages&#34;)

from . import col_generation
from .col_generation import (
    Bin,
    OneHotEncode,
    MapColVals,
    ApplyToRows,
    ApplyByCols,
    ColByFrameFunc,
    AggByCols,
    Log,
)

core.__load_stage_attributes_from_module__(&#34;pdpipe.col_generation&#34;)

from . import text_stages
from .text_stages import (
    RegexReplace,
    DropTokensByLength,
    DropTokensByList,
)

core.__load_stage_attributes_from_module__(&#34;pdpipe.text_stages&#34;)

from . import wrappers
from .wrappers import (
    FitOnly,
)

core.__load_stage_attributes_from_module__(&#34;pdpipe.wrappers&#34;)

try:
    from . import sklearn_stages
    from .sklearn_stages import (
        Encode,
        Scale,
        TfidfVectorizeTokenLists,
    )

    core.__load_stage_attributes_from_module__(&#34;pdpipe.sklearn_stages&#34;)
except ImportError:
    tb = traceback.format_exc()
    warnings.warn(tb)
    warnings.warn(
        &#34;pdpipe: Scikit-learn or skutil import failed. Scikit-learn&#34;
        &#34;-dependent pipeline stages will not be loaded.&#34;
    )

try:
    from . import nltk_stages
    from .nltk_stages import (
        TokenizeText,
        UntokenizeText,
        RemoveStopwords,
        SnowballStem,
        DropRareTokens,
    )

    core.__load_stage_attributes_from_module__(&#34;pdpipe.nltk_stages&#34;)
except ImportError:
    tb = traceback.format_exc()
    warnings.warn(tb)
    warnings.warn(
        &#34;pdpipe: nltk import failed. nltk-dependent  pipeline &#34;
        &#34;stages will not be loaded.&#34;
    )

from . import cq
from . import cond


from ._version import get_versions

__version__ = get_versions()[&#34;version&#34;]

for name in [
    &#34;warnings&#34;,
    &#34;traceback&#34;,
    &#34;_custom_formatwarning&#34;,
    &#34;core&#34;,
    &#34;basic_stages&#34;,
    &#34;sklearn_stages&#34;,
    &#34;col_generation&#34;,
    &#34;shared&#34;,
    &#34;util&#34;,
    &#34;_version&#34;,
    &#34;get_versions&#34;,
]:
    try:
        globals().pop(name)
    except KeyError:
        pass
try:
    del name  # pylint: disable=W0631
except NameError:
    pass

# this dictates which modules are skipped on pdoc documentation generation
__pdoc__ = {
    &#39;shared&#39;: False,
}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pdpipe.basic_stages" href="basic_stages.html">pdpipe.basic_stages</a></code></dt>
<dd>
<div class="desc"><p>Basic pdpipe PdPipelineStages.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.col_generation" href="col_generation.html">pdpipe.col_generation</a></code></dt>
<dd>
<div class="desc"><p>Basic pdpipe PdPipelineStages.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.cond" href="cond.html">pdpipe.cond</a></code></dt>
<dd>
<div class="desc"><p>Fittable conditions for pdpipe â€¦</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.core" href="core.html">pdpipe.core</a></code></dt>
<dd>
<div class="desc"><p>Defines pipelines for processing pandas.DataFrame-based datasets â€¦</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.cq" href="cq.html">pdpipe.cq</a></code></dt>
<dd>
<div class="desc"><p>Column qualifiers for pdpipe â€¦</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.exceptions" href="exceptions.html">pdpipe.exceptions</a></code></dt>
<dd>
<div class="desc"><p>Custom exceptions for pdpipe.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.nltk_stages" href="nltk_stages.html">pdpipe.nltk_stages</a></code></dt>
<dd>
<div class="desc"><p>PdPipeline stages dependent on the nltk Python library â€¦</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.skintegrate" href="skintegrate.html">pdpipe.skintegrate</a></code></dt>
<dd>
<div class="desc"><p>Classes for sklearn integration.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.sklearn_stages" href="sklearn_stages.html">pdpipe.sklearn_stages</a></code></dt>
<dd>
<div class="desc"><p>PdPipeline stages dependent on the scikit-learn Python library â€¦</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.text_stages" href="text_stages.html">pdpipe.text_stages</a></code></dt>
<dd>
<div class="desc"><p>Text processing pdpipe pipeline stages.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.types" href="types.html">pdpipe.types</a></code></dt>
<dd>
<div class="desc"><p>Custom types for pdpipe.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.util" href="util.html">pdpipe.util</a></code></dt>
<dd>
<div class="desc"><p>Utility methods for pdpipe.</p></div>
</dd>
<dt><code class="name"><a title="pdpipe.wrappers" href="wrappers.html">pdpipe.wrappers</a></code></dt>
<dd>
<div class="desc"><p>Wrapper-kind pdpipe pipline stages.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#features">Features</a><ul>
<li><a href="#design-decisions">Design Decisions</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#basic-use">Basic Use</a><ul>
<li><a href="#pipeline-stages">Pipeline Stages</a><ul>
<li><a href="#creating-pipeline-stages">Creating Pipeline Stages</a></li>
<li><a href="#applying-pipeline-stages">Applying Pipeline Stages</a></li>
<li><a href="#fittable-pipeline-stages">Fittable Pipeline Stages</a></li>
</ul>
</li>
<li><a href="#pipelines">Pipelines</a><ul>
<li><a href="#creating-pipelines">Creating Pipelines</a></li>
<li><a href="#printing-pipelines">Printing Pipelines</a></li>
<li><a href="#pipeline-arithmetics">Pipeline Arithmetics</a></li>
<li><a href="#pipeline-chaining">Pipeline Chaining</a></li>
<li><a href="#pipeline-slicing">Pipeline Slicing</a></li>
<li><a href="#applying-pipelines">Applying Pipelines</a></li>
</ul>
</li>
<li><a href="#column-qualifiers">Column Qualifiers</a></li>
</ul>
</li>
<li><a href="#types-of-pipeline-stages">Types of Pipeline Stages</a><ul>
<li><a href="#basic-stages">Basic Stages</a></li>
<li><a href="#column-generation">Column Generation</a></li>
<li><a href="#text-stages">Text Stages</a></li>
<li><a href="#scikit-learn-dependent-stages">Scikit-learn-dependent Stages</a></li>
<li><a href="#nltk-dependent-stages">nltk-dependent Stages</a></li>
</ul>
</li>
<li><a href="#creating-additional-stages">Creating additional stages</a><ul>
<li><a href="#extending-pdpipelinestage">Extending PdPipelineStage</a></li>
<li><a href="#ad-hoc-pipeline-stages">Ad-Hoc Pipeline Stages</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pdpipe.basic_stages" href="basic_stages.html">pdpipe.basic_stages</a></code></li>
<li><code><a title="pdpipe.col_generation" href="col_generation.html">pdpipe.col_generation</a></code></li>
<li><code><a title="pdpipe.cond" href="cond.html">pdpipe.cond</a></code></li>
<li><code><a title="pdpipe.core" href="core.html">pdpipe.core</a></code></li>
<li><code><a title="pdpipe.cq" href="cq.html">pdpipe.cq</a></code></li>
<li><code><a title="pdpipe.exceptions" href="exceptions.html">pdpipe.exceptions</a></code></li>
<li><code><a title="pdpipe.nltk_stages" href="nltk_stages.html">pdpipe.nltk_stages</a></code></li>
<li><code><a title="pdpipe.skintegrate" href="skintegrate.html">pdpipe.skintegrate</a></code></li>
<li><code><a title="pdpipe.sklearn_stages" href="sklearn_stages.html">pdpipe.sklearn_stages</a></code></li>
<li><code><a title="pdpipe.text_stages" href="text_stages.html">pdpipe.text_stages</a></code></li>
<li><code><a title="pdpipe.types" href="types.html">pdpipe.types</a></code></li>
<li><code><a title="pdpipe.util" href="util.html">pdpipe.util</a></code></li>
<li><code><a title="pdpipe.wrappers" href="wrappers.html">pdpipe.wrappers</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>