<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdpipe.cond API documentation</title>
<meta name="description" content="Fittable conditions for pdpipe â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdpipe.cond</code></h1>
</header>
<section id="section-intro">
<p>Fittable conditions for pdpipe.</p>
<p>In <code><a title="pdpipe" href="index.html">pdpipe</a></code>, pipeline stages have two optional constructor parameters that
accept callables that are treated as conditions: <code>prec</code> and <code>skip</code>. Both assume
input callables can accept a pandas.Dataframe object as input and return either
True or False. <code>prec</code> - representing the stage's precondition - determines
whether a stage <em>can</em> be applied to an input dataframe, while <code>skip</code> -
representing the stage's skip condition - determines whether it <em>should</em> be
applied. Accordingly, a stage throws a <code>FailedPreconditionError</code> if its
precondition is not satisfied, while it is skipped if its skip-condition is
satisfied.</p>
<p>This module - <code><a title="pdpipe.cond" href="#pdpipe.cond">pdpipe.cond</a></code> - provides a way to easily generate <code><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></code>
objects, which are callable, and can easily be made fittable - to have their
result determined in fit time and preserved for future transforms - by
assigning the constructor parameter <code>fittable=True</code>. This enables the creation
of pipeline stages whose their effective inclusion in the pipeline is
determined only
when <code>fit_transform</code> is called; for example, whether
dimensionality reduction is required - once this decision is done in training
time it should be maintained for all future transforms of data (in test and
validation sets or in production).</p>
<p>Conditions objects also support the &amp;, ^ and | binary operators - representing
boolean and, xor and or, respectively - and the ~ unary operator - representing
the boolean not operator.</p>
<p>So, for example, to get a condition that is satisfied by dataframes that are
missing at least one column from a list of column labels. one can use:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = ~ pdp.cond.HasAllColumns(['num', 'chr'])
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = ~ pdp.cond.HasAllColumns(['num','go'])
&gt;&gt;&gt; cond(df)
True
</code></pre>
<p>Similarly, to get a condition that is satisfied by dataframes that both has
columns names 'foo' and 'bar' AND has no missing values.</p>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8, None],[5, 2]], [1,2], ['foo', 'bar'])
&gt;&gt;&gt; col_cond = pdp.cond.HasAllColumns(['foo', 'bar'])
&gt;&gt;&gt; missing_cond = pdp.cond.HasNoMissingValues()
&gt;&gt;&gt; (col_cond | missing_cond)(df)
True
&gt;&gt;&gt; (col_cond &amp; missing_cond)(df)
False
&gt;&gt;&gt; df = pd.DataFrame([[8, 9],[5, 2]], [1,2], ['foo', 'bar'])
&gt;&gt;&gt; (col_cond &amp; missing_cond)(df)
True
</code></pre>
<p>While the same code but with XOR will yield the opposite results:</p>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8, None],[5, 2]], [1,2], ['foo', 'bar'])
&gt;&gt;&gt; col_cond = pdp.cond.HasAllColumns(['foo', 'bar'])
&gt;&gt;&gt; missing_cond = pdp.cond.HasNoMissingValues()
&gt;&gt;&gt; (col_cond ^ missing_cond)(df)
True
&gt;&gt;&gt; df = pd.DataFrame([[8, 9],[5, 2]], [1,2], ['foo', 'bar'])
&gt;&gt;&gt; (col_cond ^ missing_cond)(df)
False
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Fittable conditions for pdpipe.

In `pdpipe`, pipeline stages have two optional constructor parameters that
accept callables that are treated as conditions: `prec` and `skip`. Both assume
input callables can accept a pandas.Dataframe object as input and return either
True or False. `prec` - representing the stage&#39;s precondition - determines
whether a stage *can* be applied to an input dataframe, while `skip` -
representing the stage&#39;s skip condition - determines whether it *should* be
applied. Accordingly, a stage throws a `FailedPreconditionError` if its
precondition is not satisfied, while it is skipped if its skip-condition is
satisfied.

This module - `pdpipe.cond` - provides a way to easily generate `Condition`
objects, which are callable, and can easily be made fittable - to have their
result determined in fit time and preserved for future transforms - by
assigning the constructor parameter `fittable=True`. This enables the creation
of pipeline stages whose their effective inclusion in the pipeline is
determined only  when `fit_transform` is called; for example, whether
dimensionality reduction is required - once this decision is done in training
time it should be maintained for all future transforms of data (in test and
validation sets or in production).

Conditions objects also support the &amp;, ^ and | binary operators - representing
boolean and, xor and or, respectively - and the ~ unary operator - representing
the boolean not operator.

So, for example, to get a condition that is satisfied by dataframes that are
missing at least one column from a list of column labels. one can use:

    &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
    &gt;&gt;&gt; df = pd.DataFrame(
    ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
    &gt;&gt;&gt; cond = ~ pdp.cond.HasAllColumns([&#39;num&#39;, &#39;chr&#39;])
    &gt;&gt;&gt; cond(df)
    False
    &gt;&gt;&gt; cond = ~ pdp.cond.HasAllColumns([&#39;num&#39;,&#39;go&#39;])
    &gt;&gt;&gt; cond(df)
    True

Similarly, to get a condition that is satisfied by dataframes that both has
columns names &#39;foo&#39; and &#39;bar&#39; AND has no missing values.

    &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
    &gt;&gt;&gt; df = pd.DataFrame([[8, None],[5, 2]], [1,2], [&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; col_cond = pdp.cond.HasAllColumns([&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; missing_cond = pdp.cond.HasNoMissingValues()
    &gt;&gt;&gt; (col_cond | missing_cond)(df)
    True
    &gt;&gt;&gt; (col_cond &amp; missing_cond)(df)
    False
    &gt;&gt;&gt; df = pd.DataFrame([[8, 9],[5, 2]], [1,2], [&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; (col_cond &amp; missing_cond)(df)
    True

While the same code but with XOR will yield the opposite results:

    &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
    &gt;&gt;&gt; df = pd.DataFrame([[8, None],[5, 2]], [1,2], [&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; col_cond = pdp.cond.HasAllColumns([&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; missing_cond = pdp.cond.HasNoMissingValues()
    &gt;&gt;&gt; (col_cond ^ missing_cond)(df)
    True
    &gt;&gt;&gt; df = pd.DataFrame([[8, 9],[5, 2]], [1,2], [&#39;foo&#39;, &#39;bar&#39;])
    &gt;&gt;&gt; (col_cond ^ missing_cond)(df)
    False
&#34;&#34;&#34;

import pandas

from .shared import _list_str


class UnfittedConditionError(Exception):
    &#34;&#34;&#34;An exception raised when a (non-fit) transform is attempted with an
    unfitted condition.
    &#34;&#34;&#34;


class Condition(object):
    &#34;&#34;&#34;A fittable condition that returns a boolean value from a dataframe.

    Parameters
    ----------
    func : callable
        A callable that given an input pandas.DataFrame objects returns a
        boolean value.
    fittable : bool, default False
        If set to True, this condition becomes fittable, and `func` is not
        called on calls of `transform()` of a fitted object. If set to False,
        the default, `func` is called on every call to transform. False by
        default.
    error_message : str, default None
        A string that describes the error when the condition fails.

    Example
    -------
        &gt;&gt;&gt; import numpy as np; import pdpipe as pdp;
        &gt;&gt;&gt; cond = pdp.cond.Condition(lambda df: &#39;a&#39; in df.columns)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: By function&gt;
        &gt;&gt;&gt; col_drop = pdp.ColDrop([&#39;lbl&#39;], prec=cond)
    &#34;&#34;&#34;

    def __init__(self, func, fittable=None, error_message=None):
        self._func = func
        self._fittable = fittable
        if error_message is not None:
            self.error_message = error_message

    def __call__(self, df):
        &#34;&#34;&#34;Returns column labels of qualified columns from an input dataframe.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True of False.
        &#34;&#34;&#34;
        try:
            return self.transform(df)
        except UnfittedConditionError:
            return self.fit_transform(df)

    def fit_transform(self, df):
        &#34;&#34;&#34;Fits this condition and returns the result.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True or False.
        &#34;&#34;&#34;
        self._result = self._func(df)
        return self._result

    def fit(self, df):
        &#34;&#34;&#34;Fits this condition on the input dataframe.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.
        &#34;&#34;&#34;
        self.fit_transform(df)

    def transform(self, df):
        &#34;&#34;&#34;Returns the result of this condition.

        Is this Condition is fittable, it will return the result that was
        determined when fitted, if it&#39;s fitted, and throw an exception
        if it is not.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True or False.
        &#34;&#34;&#34;
        if not self._fittable:
            return self._func(df)
        try:
            return self._result
        except AttributeError:
            raise UnfittedConditionError

    def __repr__(self):
        fstr = &#39;&#39;
        if self._func.__doc__:  # pragma: no cover
            fstr = f&#39; - {self._func.__doc__}&#39;
        return f&#34;&lt;pdpipe.Condition: By function{fstr}&gt;&#34;

    # --- overriding boolean operators ---

    # need this because inner-scope functions aren&#39;t pickle-able
    class _AndCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) and self.second(df)

    def __and__(self, other):
        try:
            _func = Condition._AndCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} AND &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _XorCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) != self.second(df)

    def __xor__(self, other):
        try:
            _func = Condition._XorCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} XOR &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _OrCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) or self.second(df)

    def __or__(self, other):
        try:
            _func = Condition._OrCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} OR &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _NotCondition(object):

        def __init__(self, first):
            self.first = first

        def __call__(self, df):
            return not self.first(df)

    def __invert__(self):
        _func = Condition._NotCondition(self._func)
        _func.__doc__ = f&#34;NOT {self._func.__doc__ or &#39;Anonymous condition&#39;}&#34;
        return Condition(func=_func)


class PerColumnCondition(Condition):
    &#34;&#34;&#34;Checks whether the columns of input dataframes satisfy a condition set.

    Parameters
    ----------
    conditions : callable or list-like
        The condition, or set of conditions, that columns of input dataframes
        must satisfy. Conditions are callables that accept a `pandas.Series`
        object and return a `bool` value.
    conditions_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced per-column, in case of
        multiple conditions. &#39;all&#39; requires a column to satisfy all conditions,
        while &#39;any&#39; requires at least one condition to be satisfied.
    columns_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced among multiple columns.
        &#39;all&#39; requires all columns of input dataframes to satisfy the given
        condition (in the case of multiple conditions, behaviour is determined
        by the `condition_reduce` parameter), while &#39;any&#39; requires at least one
        column to satisfy it.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import numpy as np;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=lambda x: x.dtype == np.int64,
        ... )
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Dataframes with all columns satisfying all \
conditions: anonymous condition&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=lambda x: x.dtype == np.int64,
        ...     columns_reduce=&#39;any&#39;,
        ... )
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=[
        ...         lambda x: x.dtype == np.int64,
        ...         lambda x: x.dtype == object,
        ...     ],
        ... )
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=[
        ...         lambda x: x.dtype == np.int64,
        ...         lambda x: x.dtype == object,
        ...     ],
        ...     conditions_reduce=&#39;any&#39;,
        ... )
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _ConditionFunction(object):

        def __init__(self, conditions, cond_reduce, col_reduce):
            self.conditions = conditions
            self.cond_reduce = cond_reduce
            self.col_reduce = col_reduce

        def __call__(self, df):
            return self.col_reduce([
                self.cond_reduce([
                    cond(df[lbl])
                    for cond in self.conditions
                ])
                for lbl in df.columns
            ])

    def __init__(self, conditions, conditions_reduce=None, columns_reduce=None,
                 **kwargs):
        # handling default args and input types
        if not hasattr(conditions, &#39;__iter__&#39;):
            conditions = [conditions]
        if conditions_reduce is None:
            conditions_reduce = &#39;all&#39;
        if columns_reduce is None:
            columns_reduce = &#39;all&#39;
        # building class attributes
        self._conditions = conditions
        self._cond_reduce_str = conditions_reduce
        self._col_reduce_str = columns_reduce
        self._conditions_str = &#39;, &#39;.join([
            c.__doc__ or &#39;anonymous condition&#39;
            for c in conditions
        ])
        if conditions_reduce == &#39;all&#39;:
            self._cond_reduce = all
        elif conditions_reduce == &#39;any&#39;:
            self._cond_reduce = any
        else:
            raise ValueError((
                &#34;The only valid arguments to the `conditions_reduce` parameter&#34;
                &#34; of PerColumnCondition are &#39;all&#39; and &#39;any&#39;!&#34;
            ))
        if columns_reduce == &#39;all&#39;:
            self._col_reduce = all
        elif columns_reduce == &#39;any&#39;:
            self._col_reduce = any
        else:
            raise ValueError((
                &#34;The only valid arguments to the `columns_reduce` parameter&#34;
                &#34; of PerColumnCondition are &#39;all&#39; and &#39;any&#39;!&#34;
            ))
        # building resulting function
        _func = PerColumnCondition._ConditionFunction(
            conditions=self._conditions,
            cond_reduce=self._cond_reduce,
            col_reduce=self._col_reduce,
        )
        doc_str = &#34;Dataframes with {} columns satisfying {} conditions: {}&#34;
        self._func_doc = doc_str.format(
            self._col_reduce_str, self._cond_reduce_str, self._conditions_str)
        _func.__doc__ = self._func_doc
        kwargs[&#39;func&#39;] = _func
        super().__init__(**kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: {self._func_doc}&gt;&#34;


class HasAllColumns(Condition):
    &#34;&#34;&#34;Checks whether input dataframes contain a list of columns.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has all columns in num&gt;
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns([&#39;num&#39;, &#39;chr&#39;])
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns([&#39;num&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    def __init__(self, labels, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        def _func(df):  # noqa: E306
            return all([
                lbl in df.columns
                for lbl in self._labels
            ])
        _func.__doc__ = f&#34;Dataframes with columns {self._labels_str}&#34;
        super_kwargs = {
            &#34;error_message&#34;: (
                f&#34;Not all required columns {self._labels_str}&#34;
                &#34; present in the input dataframe.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: Has all columns in {self._labels_str}&gt;&#34;


class ColumnsFromList(PerColumnCondition):
    &#34;&#34;&#34;Checks whether input dataframes contain columns from a list.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    columns_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced among multiple columns.
        &#39;all&#39; requires all columns of input dataframes to satisfy the given
        condition, while &#39;any&#39; requires at least one column to satisfy it.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Dataframes with all columns satisfying all \
conditions: Series with labels in num&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList([&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(
        ...     [&#39;num&#39;, &#39;gar&#39;], columns_reduce=&#39;any&#39;)
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _SeriesLblCondition(object):

        def __init__(self, labels):
            self.labels = labels

        def __call__(self, series):
            return series.name in self.labels

    def __init__(self, labels, columns_reduce=None, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        _func = ColumnsFromList._SeriesLblCondition(self._labels)
        _func.__doc__ = f&#34;Series with labels in {self._labels_str}&#34;
        kwargs[&#39;conditions&#39;] = [_func]
        kwargs[&#39;columns_reduce&#39;] = columns_reduce
        super().__init__(**kwargs)


class HasNoColumn(Condition):
    &#34;&#34;&#34;Checks whether input dataframes contains no column from a list.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has no column in num&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn([&#39;num&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn([&#39;ph&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _NoColumnsFunc(object):

        def __init__(self, labels):
            self.labels = labels

        def __call__(self, df):
            return all([
                lbl not in df.columns
                for lbl in self.labels
            ])

    def __init__(self, labels, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        _func = HasNoColumn._NoColumnsFunc(self._labels)
        _func.__doc__ = f&#34;Dataframes with no column from {self._labels_str}&#34;
        super_kwargs = {
            &#34;error_message&#34;: (
                f&#34;One or more of the prohibited columns {self._labels_str}&#34;
                &#34; present in the input dataframe.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: Has no column in {self._labels_str}&gt;&#34;


class HasAtMostMissingValues(Condition):
    &#34;&#34;&#34;Checks whether input dataframes has no more than X missing values
    across all columns.

    Parameters
    ----------
    n_missing : int or float
        If int, then interpreted as the maximal allowed number of missing
        values in input dataframes. If float, interpreted as the maximal
        allowed ratio of missing values in input dataframes.
    **kwargs
        Additionally accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[None,&#39;a&#39;,5],[5,None,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(1)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has at most 1 missing values&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(2)
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.4)
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.2)
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    class _IntMissingValuesFunc(object):

        def __init__(self, n_missing):
            self.n_missing = n_missing

        def __call__(self, df):
            nmiss = df.isna().sum().sum()
            return nmiss &lt;= self.n_missing

    class _FloatMissingValuesFunc(object):

        def __init__(self, n_missing):
            self.n_missing = n_missing

        def __call__(self, df):
            nmiss = df.isna().sum().sum()
            return (nmiss / df.size) &lt;= self.n_missing

    def __init__(self, n_missing, **kwargs):
        self._n_missing = n_missing
        if isinstance(n_missing, int):
            _func = HasAtMostMissingValues._IntMissingValuesFunc(n_missing)
        elif isinstance(n_missing, float):
            _func = HasAtMostMissingValues._FloatMissingValuesFunc(n_missing)
        else:
            raise ValueError(&#34;n_missing should be of type int or float!&#34;)
        _func.__doc__ = (
            f&#34;Dataframes with at most {self._n_missing} missing values&#34;
        )
        super_kwargs = {
            &#34;error_message&#34;: (
                &#34;Input dataframe cannot have more than&#34;
                f&#34; {self._n_missing} missing values.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: &#34; \
               f&#34;Has at most {self._n_missing} missing values&gt;&#34;


class HasNoMissingValues(HasAtMostMissingValues):
    &#34;&#34;&#34;Checks whether input dataframes has no missing values.

    Parameters
    ----------
    **kwargs
        Accepts all keyword arguments of the constructor of Condition. See the
        documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[None,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasNoMissingValues()
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has no missing values&gt;
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super_kwargs = {
            &#34;error_message&#34;: &#34;Input dataframe cannot contain missing values.&#34;
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;n_missing&#39;] = 0
        super().__init__(**super_kwargs)

    def __repr__(self):
        return &#34;&lt;pdpipe.Condition: Has no missing values&gt;&#34;


def _AlwaysTrue(df: pandas.DataFrame) -&gt; bool:
    &#34;&#34;&#34;A function that always returns True.&#34;&#34;&#34;
    return True


class AlwaysTrue(Condition):
    &#34;&#34;&#34;A condition letting all dataframes through, always returning True.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.AlwaysTrue()
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: AlwaysTrue&gt;
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super_kwargs = {}
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _AlwaysTrue
        super().__init__(**super_kwargs)

    def __repr__(self):
        return &#34;&lt;pdpipe.Condition: AlwaysTrue&gt;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdpipe.cond.AlwaysTrue"><code class="flex name class">
<span>class <span class="ident">AlwaysTrue</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A condition letting all dataframes through, always returning True.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.AlwaysTrue()
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: AlwaysTrue&gt;
&gt;&gt;&gt; cond(df)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlwaysTrue(Condition):
    &#34;&#34;&#34;A condition letting all dataframes through, always returning True.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.AlwaysTrue()
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: AlwaysTrue&gt;
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super_kwargs = {}
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _AlwaysTrue
        super().__init__(**super_kwargs)

    def __repr__(self):
        return &#34;&lt;pdpipe.Condition: AlwaysTrue&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.ColumnsFromList"><code class="flex name class">
<span>class <span class="ident">ColumnsFromList</span></span>
<span>(</span><span>labels, columns_reduce=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether input dataframes contain columns from a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>single label</code> or <code>list-like</code></dt>
<dd>Column labels to check for.</dd>
<dt><strong><code>columns_reduce</code></strong> :&ensp;<code>str</code>, default <code>'all'</code></dt>
<dd>How condition satisfaction results are reduced among multiple columns.
'all' requires all columns of input dataframes to satisfy the given
condition, while 'any' requires at least one column to satisfy it.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionaly accepts all keyword arguments of the constructor of
Condition. See the documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.ColumnsFromList('num')
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Dataframes with all columns satisfying all conditions: Series with labels in num&gt;
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(['num', 'chr', 'nur'])
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(
...     ['num', 'gar'], columns_reduce='any')
&gt;&gt;&gt; cond(df)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnsFromList(PerColumnCondition):
    &#34;&#34;&#34;Checks whether input dataframes contain columns from a list.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    columns_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced among multiple columns.
        &#39;all&#39; requires all columns of input dataframes to satisfy the given
        condition, while &#39;any&#39; requires at least one column to satisfy it.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Dataframes with all columns satisfying all \
conditions: Series with labels in num&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList([&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.ColumnsFromList(
        ...     [&#39;num&#39;, &#39;gar&#39;], columns_reduce=&#39;any&#39;)
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _SeriesLblCondition(object):

        def __init__(self, labels):
            self.labels = labels

        def __call__(self, series):
            return series.name in self.labels

    def __init__(self, labels, columns_reduce=None, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        _func = ColumnsFromList._SeriesLblCondition(self._labels)
        _func.__doc__ = f&#34;Series with labels in {self._labels_str}&#34;
        kwargs[&#39;conditions&#39;] = [_func]
        kwargs[&#39;columns_reduce&#39;] = columns_reduce
        super().__init__(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.PerColumnCondition" href="#pdpipe.cond.PerColumnCondition">PerColumnCondition</a></li>
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.PerColumnCondition" href="#pdpipe.cond.PerColumnCondition">PerColumnCondition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.PerColumnCondition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.PerColumnCondition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.PerColumnCondition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.Condition"><code class="flex name class">
<span>class <span class="ident">Condition</span></span>
<span>(</span><span>func, fittable=None, error_message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A fittable condition that returns a boolean value from a dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>callable</code></dt>
<dd>A callable that given an input pandas.DataFrame objects returns a
boolean value.</dd>
<dt><strong><code>fittable</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, this condition becomes fittable, and <code>func</code> is not
called on calls of <code>transform()</code> of a fitted object. If set to False,
the default, <code>func</code> is called on every call to transform. False by
default.</dd>
<dt><strong><code>error_message</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A string that describes the error when the condition fails.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import numpy as np; import pdpipe as pdp;
&gt;&gt;&gt; cond = pdp.cond.Condition(lambda df: 'a' in df.columns)
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: By function&gt;
&gt;&gt;&gt; col_drop = pdp.ColDrop(['lbl'], prec=cond)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Condition(object):
    &#34;&#34;&#34;A fittable condition that returns a boolean value from a dataframe.

    Parameters
    ----------
    func : callable
        A callable that given an input pandas.DataFrame objects returns a
        boolean value.
    fittable : bool, default False
        If set to True, this condition becomes fittable, and `func` is not
        called on calls of `transform()` of a fitted object. If set to False,
        the default, `func` is called on every call to transform. False by
        default.
    error_message : str, default None
        A string that describes the error when the condition fails.

    Example
    -------
        &gt;&gt;&gt; import numpy as np; import pdpipe as pdp;
        &gt;&gt;&gt; cond = pdp.cond.Condition(lambda df: &#39;a&#39; in df.columns)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: By function&gt;
        &gt;&gt;&gt; col_drop = pdp.ColDrop([&#39;lbl&#39;], prec=cond)
    &#34;&#34;&#34;

    def __init__(self, func, fittable=None, error_message=None):
        self._func = func
        self._fittable = fittable
        if error_message is not None:
            self.error_message = error_message

    def __call__(self, df):
        &#34;&#34;&#34;Returns column labels of qualified columns from an input dataframe.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True of False.
        &#34;&#34;&#34;
        try:
            return self.transform(df)
        except UnfittedConditionError:
            return self.fit_transform(df)

    def fit_transform(self, df):
        &#34;&#34;&#34;Fits this condition and returns the result.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True or False.
        &#34;&#34;&#34;
        self._result = self._func(df)
        return self._result

    def fit(self, df):
        &#34;&#34;&#34;Fits this condition on the input dataframe.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.
        &#34;&#34;&#34;
        self.fit_transform(df)

    def transform(self, df):
        &#34;&#34;&#34;Returns the result of this condition.

        Is this Condition is fittable, it will return the result that was
        determined when fitted, if it&#39;s fitted, and throw an exception
        if it is not.

        Parameters
        ----------
        df : pandas.DataFrame
            The input dataframe on which the condition is checked.

        Returns
        -------
        bool
            Either True or False.
        &#34;&#34;&#34;
        if not self._fittable:
            return self._func(df)
        try:
            return self._result
        except AttributeError:
            raise UnfittedConditionError

    def __repr__(self):
        fstr = &#39;&#39;
        if self._func.__doc__:  # pragma: no cover
            fstr = f&#39; - {self._func.__doc__}&#39;
        return f&#34;&lt;pdpipe.Condition: By function{fstr}&gt;&#34;

    # --- overriding boolean operators ---

    # need this because inner-scope functions aren&#39;t pickle-able
    class _AndCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) and self.second(df)

    def __and__(self, other):
        try:
            _func = Condition._AndCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} AND &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _XorCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) != self.second(df)

    def __xor__(self, other):
        try:
            _func = Condition._XorCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} XOR &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _OrCondition(object):

        def __init__(self, first, second):
            self.first = first
            self.second = second

        def __call__(self, df):
            return self.first(df) or self.second(df)

    def __or__(self, other):
        try:
            _func = Condition._OrCondition(self._func, other._func)
            _func.__doc__ = (
                f&#34;{self._func.__doc__ or &#39;Anonymous condition 1&#39;} OR &#34;
                f&#34;{other._func.__doc__ or &#39;Anonymous condition 2&#39;}&#34;
            )
            return Condition(func=_func)
        except AttributeError:
            return NotImplemented

    class _NotCondition(object):

        def __init__(self, first):
            self.first = first

        def __call__(self, df):
            return not self.first(df)

    def __invert__(self):
        _func = Condition._NotCondition(self._func)
        _func.__doc__ = f&#34;NOT {self._func.__doc__ or &#39;Anonymous condition&#39;}&#34;
        return Condition(func=_func)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.AlwaysTrue" href="#pdpipe.cond.AlwaysTrue">AlwaysTrue</a></li>
<li><a title="pdpipe.cond.HasAllColumns" href="#pdpipe.cond.HasAllColumns">HasAllColumns</a></li>
<li><a title="pdpipe.cond.HasAtMostMissingValues" href="#pdpipe.cond.HasAtMostMissingValues">HasAtMostMissingValues</a></li>
<li><a title="pdpipe.cond.HasNoColumn" href="#pdpipe.cond.HasNoColumn">HasNoColumn</a></li>
<li><a title="pdpipe.cond.PerColumnCondition" href="#pdpipe.cond.PerColumnCondition">PerColumnCondition</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.cond.Condition.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this condition on the input dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The input dataframe on which the condition is checked.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, df):
    &#34;&#34;&#34;Fits this condition on the input dataframe.

    Parameters
    ----------
    df : pandas.DataFrame
        The input dataframe on which the condition is checked.
    &#34;&#34;&#34;
    self.fit_transform(df)</code></pre>
</details>
</dd>
<dt id="pdpipe.cond.Condition.fit_transform"><code class="name flex">
<span>def <span class="ident">fit_transform</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this condition and returns the result.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The input dataframe on which the condition is checked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Either True or False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_transform(self, df):
    &#34;&#34;&#34;Fits this condition and returns the result.

    Parameters
    ----------
    df : pandas.DataFrame
        The input dataframe on which the condition is checked.

    Returns
    -------
    bool
        Either True or False.
    &#34;&#34;&#34;
    self._result = self._func(df)
    return self._result</code></pre>
</details>
</dd>
<dt id="pdpipe.cond.Condition.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the result of this condition.</p>
<p>Is this Condition is fittable, it will return the result that was
determined when fitted, if it's fitted, and throw an exception
if it is not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The input dataframe on which the condition is checked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Either True or False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, df):
    &#34;&#34;&#34;Returns the result of this condition.

    Is this Condition is fittable, it will return the result that was
    determined when fitted, if it&#39;s fitted, and throw an exception
    if it is not.

    Parameters
    ----------
    df : pandas.DataFrame
        The input dataframe on which the condition is checked.

    Returns
    -------
    bool
        Either True or False.
    &#34;&#34;&#34;
    if not self._fittable:
        return self._func(df)
    try:
        return self._result
    except AttributeError:
        raise UnfittedConditionError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pdpipe.cond.HasAllColumns"><code class="flex name class">
<span>class <span class="ident">HasAllColumns</span></span>
<span>(</span><span>labels, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether input dataframes contain a list of columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>single label</code> or <code>list-like</code></dt>
<dd>Column labels to check for.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionaly accepts all keyword arguments of the constructor of
Condition. See the documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.HasAllColumns('num')
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Has all columns in num&gt;
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.HasAllColumns(['num', 'chr'])
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.HasAllColumns(['num', 'gar'])
&gt;&gt;&gt; cond(df)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasAllColumns(Condition):
    &#34;&#34;&#34;Checks whether input dataframes contain a list of columns.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has all columns in num&gt;
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns([&#39;num&#39;, &#39;chr&#39;])
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAllColumns([&#39;num&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    def __init__(self, labels, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        def _func(df):  # noqa: E306
            return all([
                lbl in df.columns
                for lbl in self._labels
            ])
        _func.__doc__ = f&#34;Dataframes with columns {self._labels_str}&#34;
        super_kwargs = {
            &#34;error_message&#34;: (
                f&#34;Not all required columns {self._labels_str}&#34;
                &#34; present in the input dataframe.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: Has all columns in {self._labels_str}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.HasAtMostMissingValues"><code class="flex name class">
<span>class <span class="ident">HasAtMostMissingValues</span></span>
<span>(</span><span>n_missing, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether input dataframes has no more than X missing values
across all columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_missing</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>If int, then interpreted as the maximal allowed number of missing
values in input dataframes. If float, interpreted as the maximal
allowed ratio of missing values in input dataframes.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionally accepts all keyword arguments of the constructor of
Condition. See the documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[None,'a',5],[5,None,7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(1)
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Has at most 1 missing values&gt;
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(2)
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.4)
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.2)
&gt;&gt;&gt; cond(df)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasAtMostMissingValues(Condition):
    &#34;&#34;&#34;Checks whether input dataframes has no more than X missing values
    across all columns.

    Parameters
    ----------
    n_missing : int or float
        If int, then interpreted as the maximal allowed number of missing
        values in input dataframes. If float, interpreted as the maximal
        allowed ratio of missing values in input dataframes.
    **kwargs
        Additionally accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[None,&#39;a&#39;,5],[5,None,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(1)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has at most 1 missing values&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(2)
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.4)
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.HasAtMostMissingValues(0.2)
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    class _IntMissingValuesFunc(object):

        def __init__(self, n_missing):
            self.n_missing = n_missing

        def __call__(self, df):
            nmiss = df.isna().sum().sum()
            return nmiss &lt;= self.n_missing

    class _FloatMissingValuesFunc(object):

        def __init__(self, n_missing):
            self.n_missing = n_missing

        def __call__(self, df):
            nmiss = df.isna().sum().sum()
            return (nmiss / df.size) &lt;= self.n_missing

    def __init__(self, n_missing, **kwargs):
        self._n_missing = n_missing
        if isinstance(n_missing, int):
            _func = HasAtMostMissingValues._IntMissingValuesFunc(n_missing)
        elif isinstance(n_missing, float):
            _func = HasAtMostMissingValues._FloatMissingValuesFunc(n_missing)
        else:
            raise ValueError(&#34;n_missing should be of type int or float!&#34;)
        _func.__doc__ = (
            f&#34;Dataframes with at most {self._n_missing} missing values&#34;
        )
        super_kwargs = {
            &#34;error_message&#34;: (
                &#34;Input dataframe cannot have more than&#34;
                f&#34; {self._n_missing} missing values.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: &#34; \
               f&#34;Has at most {self._n_missing} missing values&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.HasNoMissingValues" href="#pdpipe.cond.HasNoMissingValues">HasNoMissingValues</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.HasNoColumn"><code class="flex name class">
<span>class <span class="ident">HasNoColumn</span></span>
<span>(</span><span>labels, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether input dataframes contains no column from a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>single label</code> or <code>list-like</code></dt>
<dd>Column labels to check for.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionaly accepts all keyword arguments of the constructor of
Condition. See the documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.HasNoColumn('num')
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Has no column in num&gt;
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.HasNoColumn(['num', 'gar'])
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.HasNoColumn(['ph', 'gar'])
&gt;&gt;&gt; cond(df)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasNoColumn(Condition):
    &#34;&#34;&#34;Checks whether input dataframes contains no column from a list.

    Parameters
    ----------
    labels : single label or list-like
        Column labels to check for.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn(&#39;num&#39;)
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has no column in num&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn([&#39;num&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.HasNoColumn([&#39;ph&#39;, &#39;gar&#39;])
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _NoColumnsFunc(object):

        def __init__(self, labels):
            self.labels = labels

        def __call__(self, df):
            return all([
                lbl not in df.columns
                for lbl in self.labels
            ])

    def __init__(self, labels, **kwargs):
        if isinstance(labels, str) or not hasattr(labels, &#39;__iter__&#39;):
            labels = [labels]
        self._labels = labels
        self._labels_str = _list_str(self._labels)
        _func = HasNoColumn._NoColumnsFunc(self._labels)
        _func.__doc__ = f&#34;Dataframes with no column from {self._labels_str}&#34;
        super_kwargs = {
            &#34;error_message&#34;: (
                f&#34;One or more of the prohibited columns {self._labels_str}&#34;
                &#34; present in the input dataframe.&#34;
            )
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;func&#39;] = _func
        super().__init__(**super_kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: Has no column in {self._labels_str}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.HasNoMissingValues"><code class="flex name class">
<span>class <span class="ident">HasNoMissingValues</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether input dataframes has no missing values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Accepts all keyword arguments of the constructor of Condition. See the
documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[None,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.HasNoMissingValues()
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Has no missing values&gt;
&gt;&gt;&gt; cond(df)
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasNoMissingValues(HasAtMostMissingValues):
    &#34;&#34;&#34;Checks whether input dataframes has no missing values.

    Parameters
    ----------
    **kwargs
        Accepts all keyword arguments of the constructor of Condition. See the
        documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[None,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.HasNoMissingValues()
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Has no missing values&gt;
        &gt;&gt;&gt; cond(df)
        False
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        super_kwargs = {
            &#34;error_message&#34;: &#34;Input dataframe cannot contain missing values.&#34;
        }
        super_kwargs.update(**kwargs)
        super_kwargs[&#39;n_missing&#39;] = 0
        super().__init__(**super_kwargs)

    def __repr__(self):
        return &#34;&lt;pdpipe.Condition: Has no missing values&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.HasAtMostMissingValues" href="#pdpipe.cond.HasAtMostMissingValues">HasAtMostMissingValues</a></li>
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.HasAtMostMissingValues" href="#pdpipe.cond.HasAtMostMissingValues">HasAtMostMissingValues</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.HasAtMostMissingValues.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.HasAtMostMissingValues.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.HasAtMostMissingValues.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.PerColumnCondition"><code class="flex name class">
<span>class <span class="ident">PerColumnCondition</span></span>
<span>(</span><span>conditions, conditions_reduce=None, columns_reduce=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the columns of input dataframes satisfy a condition set.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conditions</code></strong> :&ensp;<code>callable</code> or <code>list-like</code></dt>
<dd>The condition, or set of conditions, that columns of input dataframes
must satisfy. Conditions are callables that accept a <code>pandas.Series</code>
object and return a <code>bool</code> value.</dd>
<dt><strong><code>conditions_reduce</code></strong> :&ensp;<code>str</code>, default <code>'all'</code></dt>
<dd>How condition satisfaction results are reduced per-column, in case of
multiple conditions. 'all' requires a column to satisfy all conditions,
while 'any' requires at least one condition to be satisfied.</dd>
<dt><strong><code>columns_reduce</code></strong> :&ensp;<code>str</code>, default <code>'all'</code></dt>
<dd>How condition satisfaction results are reduced among multiple columns.
'all' requires all columns of input dataframes to satisfy the given
condition (in the case of multiple conditions, behaviour is determined
by the <code>condition_reduce</code> parameter), while 'any' requires at least one
column to satisfy it.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionaly accepts all keyword arguments of the constructor of
Condition. See the documentation of Condition for details.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import numpy as np;
&gt;&gt;&gt; df = pd.DataFrame(
...    [[8,'a',5],[5,'b',7]], [1,2], ['num', 'chr', 'nur'])
&gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
...     conditions=lambda x: x.dtype == np.int64,
... )
&gt;&gt;&gt; cond
&lt;pdpipe.Condition: Dataframes with all columns satisfying all conditions: anonymous condition&gt;
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
...     conditions=lambda x: x.dtype == np.int64,
...     columns_reduce='any',
... )
&gt;&gt;&gt; cond(df)
True
&gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
...     conditions=[
...         lambda x: x.dtype == np.int64,
...         lambda x: x.dtype == object,
...     ],
... )
&gt;&gt;&gt; cond(df)
False
&gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
...     conditions=[
...         lambda x: x.dtype == np.int64,
...         lambda x: x.dtype == object,
...     ],
...     conditions_reduce='any',
... )
&gt;&gt;&gt; cond(df)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerColumnCondition(Condition):
    &#34;&#34;&#34;Checks whether the columns of input dataframes satisfy a condition set.

    Parameters
    ----------
    conditions : callable or list-like
        The condition, or set of conditions, that columns of input dataframes
        must satisfy. Conditions are callables that accept a `pandas.Series`
        object and return a `bool` value.
    conditions_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced per-column, in case of
        multiple conditions. &#39;all&#39; requires a column to satisfy all conditions,
        while &#39;any&#39; requires at least one condition to be satisfied.
    columns_reduce : str, default &#39;all&#39;
        How condition satisfaction results are reduced among multiple columns.
        &#39;all&#39; requires all columns of input dataframes to satisfy the given
        condition (in the case of multiple conditions, behaviour is determined
        by the `condition_reduce` parameter), while &#39;any&#39; requires at least one
        column to satisfy it.
    **kwargs
        Additionaly accepts all keyword arguments of the constructor of
        Condition. See the documentation of Condition for details.

    Example
    -------
        &gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import numpy as np;
        &gt;&gt;&gt; df = pd.DataFrame(
        ...    [[8,&#39;a&#39;,5],[5,&#39;b&#39;,7]], [1,2], [&#39;num&#39;, &#39;chr&#39;, &#39;nur&#39;])
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=lambda x: x.dtype == np.int64,
        ... )
        &gt;&gt;&gt; cond
        &lt;pdpipe.Condition: Dataframes with all columns satisfying all \
conditions: anonymous condition&gt;
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=lambda x: x.dtype == np.int64,
        ...     columns_reduce=&#39;any&#39;,
        ... )
        &gt;&gt;&gt; cond(df)
        True
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=[
        ...         lambda x: x.dtype == np.int64,
        ...         lambda x: x.dtype == object,
        ...     ],
        ... )
        &gt;&gt;&gt; cond(df)
        False
        &gt;&gt;&gt; cond = pdp.cond.PerColumnCondition(
        ...     conditions=[
        ...         lambda x: x.dtype == np.int64,
        ...         lambda x: x.dtype == object,
        ...     ],
        ...     conditions_reduce=&#39;any&#39;,
        ... )
        &gt;&gt;&gt; cond(df)
        True
    &#34;&#34;&#34;

    class _ConditionFunction(object):

        def __init__(self, conditions, cond_reduce, col_reduce):
            self.conditions = conditions
            self.cond_reduce = cond_reduce
            self.col_reduce = col_reduce

        def __call__(self, df):
            return self.col_reduce([
                self.cond_reduce([
                    cond(df[lbl])
                    for cond in self.conditions
                ])
                for lbl in df.columns
            ])

    def __init__(self, conditions, conditions_reduce=None, columns_reduce=None,
                 **kwargs):
        # handling default args and input types
        if not hasattr(conditions, &#39;__iter__&#39;):
            conditions = [conditions]
        if conditions_reduce is None:
            conditions_reduce = &#39;all&#39;
        if columns_reduce is None:
            columns_reduce = &#39;all&#39;
        # building class attributes
        self._conditions = conditions
        self._cond_reduce_str = conditions_reduce
        self._col_reduce_str = columns_reduce
        self._conditions_str = &#39;, &#39;.join([
            c.__doc__ or &#39;anonymous condition&#39;
            for c in conditions
        ])
        if conditions_reduce == &#39;all&#39;:
            self._cond_reduce = all
        elif conditions_reduce == &#39;any&#39;:
            self._cond_reduce = any
        else:
            raise ValueError((
                &#34;The only valid arguments to the `conditions_reduce` parameter&#34;
                &#34; of PerColumnCondition are &#39;all&#39; and &#39;any&#39;!&#34;
            ))
        if columns_reduce == &#39;all&#39;:
            self._col_reduce = all
        elif columns_reduce == &#39;any&#39;:
            self._col_reduce = any
        else:
            raise ValueError((
                &#34;The only valid arguments to the `columns_reduce` parameter&#34;
                &#34; of PerColumnCondition are &#39;all&#39; and &#39;any&#39;!&#34;
            ))
        # building resulting function
        _func = PerColumnCondition._ConditionFunction(
            conditions=self._conditions,
            cond_reduce=self._cond_reduce,
            col_reduce=self._col_reduce,
        )
        doc_str = &#34;Dataframes with {} columns satisfying {} conditions: {}&#34;
        self._func_doc = doc_str.format(
            self._col_reduce_str, self._cond_reduce_str, self._conditions_str)
        _func.__doc__ = self._func_doc
        kwargs[&#39;func&#39;] = _func
        super().__init__(**kwargs)

    def __repr__(self):
        return f&#34;&lt;pdpipe.Condition: {self._func_doc}&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.cond.ColumnsFromList" href="#pdpipe.cond.ColumnsFromList">ColumnsFromList</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.cond.UnfittedConditionError"><code class="flex name class">
<span>class <span class="ident">UnfittedConditionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception raised when a (non-fit) transform is attempted with an
unfitted condition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnfittedConditionError(Exception):
    &#34;&#34;&#34;An exception raised when a (non-fit) transform is attempted with an
    unfitted condition.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdpipe" href="index.html">pdpipe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdpipe.cond.AlwaysTrue" href="#pdpipe.cond.AlwaysTrue">AlwaysTrue</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.ColumnsFromList" href="#pdpipe.cond.ColumnsFromList">ColumnsFromList</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.Condition" href="#pdpipe.cond.Condition">Condition</a></code></h4>
<ul class="">
<li><code><a title="pdpipe.cond.Condition.fit" href="#pdpipe.cond.Condition.fit">fit</a></code></li>
<li><code><a title="pdpipe.cond.Condition.fit_transform" href="#pdpipe.cond.Condition.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.cond.Condition.transform" href="#pdpipe.cond.Condition.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdpipe.cond.HasAllColumns" href="#pdpipe.cond.HasAllColumns">HasAllColumns</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.HasAtMostMissingValues" href="#pdpipe.cond.HasAtMostMissingValues">HasAtMostMissingValues</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.HasNoColumn" href="#pdpipe.cond.HasNoColumn">HasNoColumn</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.HasNoMissingValues" href="#pdpipe.cond.HasNoMissingValues">HasNoMissingValues</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.PerColumnCondition" href="#pdpipe.cond.PerColumnCondition">PerColumnCondition</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.cond.UnfittedConditionError" href="#pdpipe.cond.UnfittedConditionError">UnfittedConditionError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>