<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdpipe.core API documentation</title>
<meta name="description" content="Defines pipelines for processing pandas.DataFrame-based datasets â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdpipe.core</code></h1>
</header>
<section id="section-intro">
<p>Defines pipelines for processing pandas.DataFrame-based datasets.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pdpipe as pdp
&gt;&gt;&gt; pipeline = pdp.ColDrop('Name') + pdp.Bin({'Speed': [0,5]})
&gt;&gt;&gt; pipeline = pdp.ColDrop('Name').Bin({'Speed': [0,5]}, drop=True)
</code></pre>
<h2 id="creating-pipeline-stages-that-operate-on-column-subsets">Creating pipeline stages that operate on column subsets</h2>
<p>Many pipeline stages in pdpipe operate on a subset of columns, allowing the
caller to deteremine this subset by either providing a fixed set of column
labels or by providing a callable that determines the column subset dynamically
from input dataframes. The <code><a title="pdpipe.cq" href="cq.html">pdpipe.cq</a></code> module addresses a unique but important
use case of fittable column qualifier, which dynamically extract a column
subset on stage fit time, but keep it fixed for future transformations.</p>
<p>As a general rule, every pipeline stage in pdpipe that supports the <code>columns</code>
parameter should inherently support fittable column qualifier, and generally
the correct interpretation of both single and multiple labels as arguments. To
unify the implementation of such functionality, and ease of creation of new
pipeline stages, such columns shoul be created by extending the
ColumnsBasedPipelineStage base class, found in this module (<code><a title="pdpipe.core" href="#pdpipe.core">pdpipe.core</a></code>).</p>
<p>The main interface of sub-classes of this base class with it is through the
<code>columns</code>, <code>exclude_columns</code> and <code>none_columns</code> constructor arguments, and the
"private" <code>_get_columns(df, fit)</code> method:</p>
<ul>
<li>
<p>Any extending subclass should accept the <code>columns</code> constructor parameter
and forward it, without transforming it, to the constructor of
ColumnsBasedPipelineStage. E.g.
<code>super().__init__(columns=columns, **kwargs)</code>. See the implementation of
any such extending class for a more complete example.</p>
</li>
<li>
<p>Extending subclasses can decide if they want to expose the
<code>exclude_columns</code> parameter or not. Note that most of its functionality
can anyway be gained by providing the <code>columns</code> parameter with a column
qualifier object that is a difference between two column qualifiers; e.g.
<code>columns=cq.OfDtype(np.number) - cq.OfDtype(np.int64)</code> is equivalent to
providing <code>columns=cq.OfDtype(np.number),
exclude_columns=cq.OfDtype(np.int64)</code>. However, exposing the
<code>exclude_columns</code> parameter can allow for specific unique behaviours; for
example, if the <code>none_columns</code> parametet - which configures the behavior
when <code>columns</code> is provided with <code>None</code> - is set with
a <code>cq.OfDtypes('category')</code> column qualifier, which means that all
categorical columns are selected when <code>columns=None</code>, then exposing
<code>exclude_columns</code> allows easy specification of the "all categorical
columns except X" by just giving a column qualifier capturing X to
<code>exclude_columns</code>, instead of having to reconstruct the default column
qualifier by hand and substract from it the one representing X.</p>
</li>
<li>
<p>When wishing to get the subset of columns to operate on, in
<code>fit_transform</code> or <code>transform</code> time, it is attained by calling
<code>self._get_columns(df, fit=True)</code> (or with <code>fit=False</code> if just
transforming), providing it the input dataframe.</p>
</li>
<li>
<p>Additionally, to get a description and application message with a nice
string representation of the list of columns to operate on, the
<code>desc_temp</code> constructor parameter of ColumnsBasedPipelineStage can be
provided with a format string with a place holder where the column list
should go. E.g. <code>"Drop columns {}"</code> for the DropCol pipeline stage.</p>
</li>
</ul>
<p>There are two correct ways to extend it, depending on whether the pipeline
stage you're creating is inherently fittable or not:</p>
<ol>
<li>
<p>If the stage is NOT inherently fittable, then the ability to accept
fittable column qualifier objects makes it so. However, to enable
extending subclasses to implement their transformation using a single
method, they can simply implement the abstract method
<code>_transformation(self, df, verbose, fit)</code>. It should treat the <code>df</code> and
<code>verbose</code> parameters normally, but forward the <code>fit</code> parameter to the
<code>_get_columns</code> method when calling it. This is enough to get a pipeline
stage with the desired behavior, with the super-class handling all the
fit/transform functionality.</p>
</li>
<li>
<p>If the stage IS inherently fittable, then do not use the
<code>_transformation</code> abstract method (it has to be implemented, so just
have it raise a NotImplementedError). Instead, simply override the
<code>_fit_transform</code> and <code>_transform</code> method of ColumnsBasedPipelineStage,
calling the <code>fit</code> parameter of the <code>_get_columns</code> method with the
correct arguement: <code>True</code> when fit-transforming and <code>False</code> when
transforming.</p>
</li>
</ol>
<p>Again, taking a look at the VERY concise implementation of simple columns-based
stages, like ColDrop or ValDrop, will probably make things clearer, and you can
use those implementations as a template for yours.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines pipelines for processing pandas.DataFrame-based datasets.

&gt;&gt;&gt; import pdpipe as pdp
&gt;&gt;&gt; pipeline = pdp.ColDrop(&#39;Name&#39;) + pdp.Bin({&#39;Speed&#39;: [0,5]})
&gt;&gt;&gt; pipeline = pdp.ColDrop(&#39;Name&#39;).Bin({&#39;Speed&#39;: [0,5]}, drop=True)

## Creating pipeline stages that operate on column subsets

Many pipeline stages in pdpipe operate on a subset of columns, allowing the
caller to deteremine this subset by either providing a fixed set of column
labels or by providing a callable that determines the column subset dynamically
from input dataframes. The `pdpipe.cq` module addresses a unique but important
use case of fittable column qualifier, which dynamically extract a column
subset on stage fit time, but keep it fixed for future transformations.

As a general rule, every pipeline stage in pdpipe that supports the `columns`
parameter should inherently support fittable column qualifier, and generally
the correct interpretation of both single and multiple labels as arguments. To
unify the implementation of such functionality, and ease of creation of new
pipeline stages, such columns shoul be created by extending the
ColumnsBasedPipelineStage base class, found in this module (`pdpipe.core`).

The main interface of sub-classes of this base class with it is through the
`columns`, `exclude_columns` and `none_columns` constructor arguments, and the
&#34;private&#34; `_get_columns(df, fit)` method:

* Any extending subclass should accept the `columns` constructor parameter
  and forward it, without transforming it, to the constructor of
  ColumnsBasedPipelineStage. E.g.
  `super().__init__(columns=columns, **kwargs)`. See the implementation of
  any such extending class for a more complete example.

* Extending subclasses can decide if they want to expose the
  `exclude_columns` parameter or not. Note that most of its functionality
  can anyway be gained by providing the `columns` parameter with a column
  qualifier object that is a difference between two column qualifiers; e.g.
  `columns=cq.OfDtype(np.number) - cq.OfDtype(np.int64)` is equivalent to
  providing `columns=cq.OfDtype(np.number),
  exclude_columns=cq.OfDtype(np.int64)`. However, exposing the
  `exclude_columns` parameter can allow for specific unique behaviours; for
  example, if the `none_columns` parametet - which configures the behavior
  when `columns` is provided with `None` - is set with
  a `cq.OfDtypes(&#39;category&#39;)` column qualifier, which means that all
  categorical columns are selected when `columns=None`, then exposing
  `exclude_columns` allows easy specification of the &#34;all categorical
  columns except X&#34; by just giving a column qualifier capturing X to
  `exclude_columns`, instead of having to reconstruct the default column
  qualifier by hand and substract from it the one representing X.

* When wishing to get the subset of columns to operate on, in
  `fit_transform` or `transform` time, it is attained by calling
  `self._get_columns(df, fit=True)` (or with `fit=False` if just
  transforming), providing it the input dataframe.

* Additionally, to get a description and application message with a nice
  string representation of the list of columns to operate on, the
  `desc_temp` constructor parameter of ColumnsBasedPipelineStage can be
  provided with a format string with a place holder where the column list
  should go. E.g. `&#34;Drop columns {}&#34;` for the DropCol pipeline stage.

There are two correct ways to extend it, depending on whether the pipeline
stage you&#39;re creating is inherently fittable or not:

1. If the stage is NOT inherently fittable, then the ability to accept
   fittable column qualifier objects makes it so. However, to enable
   extending subclasses to implement their transformation using a single
   method, they can simply implement the abstract method
   `_transformation(self, df, verbose, fit)`. It should treat the `df` and
   `verbose` parameters normally, but forward the `fit` parameter to the
   `_get_columns` method when calling it. This is enough to get a pipeline
   stage with the desired behavior, with the super-class handling all the
   fit/transform functionality.

2. If the stage IS inherently fittable, then do not use the
   `_transformation` abstract method (it has to be implemented, so just
   have it raise a NotImplementedError). Instead, simply override the
   `_fit_transform` and `_transform` method of ColumnsBasedPipelineStage,
   calling the `fit` parameter of the `_get_columns` method with the
   correct arguement: `True` when fit-transforming and `False` when
   transforming.

Again, taking a look at the VERY concise implementation of simple columns-based
stages, like ColDrop or ValDrop, will probably make things clearer, and you can
use those implementations as a template for yours.
&#34;&#34;&#34;

import sys
import abc
import time
import inspect
import collections
import textwrap

try:
    from pympler.asizeof import asizeof
except ImportError:
    from sys import getsizeof as asizeof

from .cq import is_fittable_column_qualifier, AllColumns
from .shared import _get_args_list
from .exceptions import (
    FailedPreconditionError,
    FailedPostconditionError,
    UnfittedPipelineStageError,
    PipelineApplicationError
)


# === loading stage attributes ===

def __get_append_stage_attr_doc(class_obj):
    doc = class_obj.__doc__
    first_line = doc[0:doc.find(&#39;.&#39;) + 1]
    if &#34;An&#34; in first_line:
        new_first_line = first_line.replace(&#34;An&#34;, &#34;Creates and adds an&#34;, 1)
    else:
        new_first_line = first_line.replace(&#34;A&#34;, &#34;Creates and adds a&#34;, 1)
    new_first_line = new_first_line[0:-1] + (
        &#34; to this pipeline stage.&#34;)
    return doc.replace(first_line, new_first_line, 1)


def __load_stage_attribute__(class_obj):

    def _append_stage_func(self, *args, **kwds):
        # self is always a PdPipelineStage
        return self + class_obj(*args, **kwds)
    _append_stage_func.__doc__ = __get_append_stage_attr_doc(class_obj)
    _append_stage_func.__name__ = class_obj.__name__  # .lower()
    _append_stage_func.__signature__ = inspect.signature(class_obj.__init__)
    setattr(PdPipelineStage, class_obj.__name__, _append_stage_func)

    # unbound_method = types.MethodType(_append_stage_func, class_obj)
    # setattr(class_obj, class_obj.__name__, unbound_method)


def __load_stage_attributes_from_module__(module_name):
    module_obj = sys.modules[module_name]
    for name, obj in inspect.getmembers(module_obj):
        if inspect.isclass(obj) and obj.__module__ == module_name:
            class_obj = getattr(module_obj, name)
            if issubclass(class_obj, PdPipelineStage) and (
                    class_obj.__name__ != &#39;PdPipelineStage&#39;):
                __load_stage_attribute__(class_obj)


# === basic classes ===

class PdpApplicationContext(dict):
    &#34;&#34;&#34;An object encapsulating the application context of a pipeline.

    It is meant to communicate data, information and variables between
    different stages of a pipeline.

    Parameters
    ----------
    fit_context : PdpApplicationContext, optional
        Another application context object, representing the application
        context of a previous fit of the pipelline this application context
        is initialized for. Optional.
    &#34;&#34;&#34;

    def __init__(self, fit_context=None):
        self.__locked__ = False
        self._fit_context__ = fit_context

    def __setitem__(self, key, value):
        if not self.__locked__:
            super().__setitem__(key, value)

    def __delitem__(self, key):
        if not self.__locked__:
            super().__delitem__(key)

    def pop(self, key, default):
        &#34;&#34;&#34;If key is in the dictionary, remove it and return its value, else
        return default. If default is not given and key is not in the
        dictionary, a KeyError is raised.
        &#34;&#34;&#34;
        if not self.__locked__:
            return super().pop(key, default)
        return super().__getitem__(key)

    def clear(self):
        &#34;&#34;&#34;Remove all items from the dictionary.&#34;&#34;&#34;
        if not self.__locked__:
            super().clear()

    def popitem(self):
        &#34;&#34;&#34;Not implemented!&#34;&#34;&#34;
        raise NotImplementedError

    def update(self, other):
        &#34;&#34;&#34;Update the dictionary with the key/value pairs from other,
        overwriting existing keys. Return None.
        update() accepts either another dictionary object or an iterable of
        key/value pairs (as tuples or other iterables of length two). If
        keyword arguments are specified, the dictionary is then updated with
        those key/value pairs: d.update(red=1, blue=2).
        &#34;&#34;&#34;
        if not self.__locked__:
            super().update(other)

    def lock(self):
        &#34;&#34;&#34;Locks this application context for changes.&#34;&#34;&#34;
        self.__locked__ = True

    def fit_context(self):
        &#34;&#34;&#34;Returns a locked PdpApplicationContext object of a previous fit.&#34;&#34;&#34;
        return self._fit_context__


class PdPipelineStage(abc.ABC):
    &#34;&#34;&#34;A stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    exraise : bool, default True
        If true, a pdpipe.FailedPreconditionError is raised when this
        stage is applied to a dataframe for which the precondition does
        not hold. Otherwise the stage is skipped. Additionally, if true, a
        pdpipe.FailedPostconditionError is raised if an expected post-codnition
        does not hold for an output dataframe (after pipeline application).
        Otherwise pipeline application continues uninterrupted.
    exmsg : str, default None
        The message of the exception that is raised on a failed
        precondition if exraise is set to True. A default message is used
        if None is given.
    desc : str, default None
        A short description of this stage, used as its string representation.
        A default description is used if None is given.
    prec : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the preconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed preconditions). See pdp.cond for
        more information on specialised Condition objects.
    post : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the postconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed postconditions). See pdp.cond for
        more information on specialised Condition objects.
    skip : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether this stage should
        be skipped for input dataframes - if the callable returns True for an
        input dataframe, this stage will be skipped. See pdp.cond for more
        information on specialised Condition objects.
    name : str, default &#39;&#39;
        The name of this stage. Pipelines can be sliced by this name.

    Attributes
    ----------
    fit_context : PdpApplicationContext
        An application context object that is only re-initialized before
        `fit_transform` calls, and is locked after pipeline application. It is
        injected into the PipelineStage by the encapsulating pipeline object.
    application_context : PdpApplicationContext
        An application context object that is re-initialized before every
        pipeline application (so, also during transform operations of fitted
        pipelines), and is locked after pipeline application.It is injected
        into the PipelineStage by the encapsulating pipeline object.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Precondition failed in stage {}!&#39;
    _DEF_DESCRIPTION = &#39;A pipeline stage.&#39;
    _INIT_KWARGS = [&#39;exraise&#39;, &#39;exmsg&#39;, &#39;desc&#39;, &#39;prec&#39;, &#39;skip&#39;, &#39;name&#39;]

    def __init__(self, exraise=True, exmsg=None, desc=None, prec=None,
                 post=None, skip=None, name=&#39;&#39;):
        if not isinstance(name, str):
            raise ValueError(
                f&#34;&#39;name&#39; must be a str, not {type(name).__name__}.&#34;
            )
        if desc is None:
            desc = PdPipelineStage._DEF_DESCRIPTION
        if exmsg is None:
            exmsg = PdPipelineStage._DEF_EXC_MSG.format(desc)

        self._exraise = exraise
        self._exmsg = exmsg
        self._exmsg_post = exmsg.replace(
            &#39;precondition&#39;, &#39;postcondition&#39;).replace(
            &#39;Precondition&#39;, &#39;Postcondition&#39;)
        self._desc = desc
        self._prec_arg = prec
        self._post_arg = post
        self._skip = skip
        self._appmsg = f&#34;{name + &#39;: &#39; if name else &#39;&#39;}{desc}&#34;
        self._name = name
        self.fit_context: PdpApplicationContext = None
        self.application_context: PdpApplicationContext = None
        self.is_fitted = False

    @classmethod
    def _init_kwargs(cls):
        return cls._INIT_KWARGS

    @abc.abstractmethod
    def _prec(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage can be applied to the given dataframe.&#34;&#34;&#34;
        raise NotImplementedError

    def _compound_prec(self, df):
        if self._prec_arg:
            return self._prec_arg(df)
        return self._prec(df)

    def _post(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage resulted in an expected output frame.&#34;&#34;&#34;
        return True

    def _compound_post(self, df):
        if self._post_arg:
            return self._post_arg(df)
        return self._post(df)

    def _fit_transform(self, df, verbose):
        &#34;&#34;&#34;Fits this stage and transforms the input dataframe.&#34;&#34;&#34;
        return self._transform(df, verbose)

    def _is_fittable(self):
        if self.__class__._fit_transform == PdPipelineStage._fit_transform:
            return False
        return True

    @abc.abstractmethod
    def _transform(self, df, verbose):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.&#34;&#34;&#34;
        raise NotImplementedError(&#34;_transform method not implemented!&#34;)

    def apply(self, df, exraise=None, verbose=False):
        &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

        If the stage is not fitted fit_transform is called. Otherwise,
        transform is called.

        Parameters
        ----------
        df : pandas.DataFrame
            The dataframe to which this pipeline stage will be applied.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._skip and self._skip(df):
            return df
        if self._compound_prec(df=df):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self.is_fitted:
                res_df = self._transform(df, verbose=verbose)
            else:
                res_df = self._fit_transform(df, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return df

    __call__ = apply

    def fit_transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline stage by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._compound_prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            res_df = self._fit_transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def fit(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._compound_prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            res_df = self._fit_transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return X
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

        If this stage is fittable but is not fitter, an
        UnfittedPipelineStageError is raised.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self._is_fittable():
                if self.is_fitted:
                    res_df = self._transform(X, verbose=verbose)
                    if exraise and not self._compound_post(df=res_df):
                        raise FailedPostconditionError(self._exmsg_post)
                    return res_df
                raise UnfittedPipelineStageError(
                    &#34;transform of an unfitted pipeline stage was called!&#34;)
            res_df = self._transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([self, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([self, other])
        return NotImplemented

    def __str__(self):
        return f&#34;PdPipelineStage: {self._desc}&#34;

    def __repr__(self):
        return self.__str__()

    def description(self):
        &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
        return self._desc

    def _mem_str(self):
        total = asizeof(self)
        lines = []
        for a in dir(self):
            if not a.startswith(&#39;__&#39;):
                att = getattr(self, a)
                if not callable(att):
                    size = asizeof(att)
                    if size &gt; 500000:  # pragma: no cover
                        lines.append(&#39;  - {}, {:.2f}Mb ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size / 1000000, 100 * size / total))
                    elif size &gt; 1000:  # pragma: no cover
                        lines.append(&#39;  - {}, {:.2f}Kb ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size / 1000, 100 * size / total))
                    else:
                        lines.append(&#39;  - {}, {}b ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size, 100 * size / total))
        return &#39;&#39;.join(lines)


class ColumnsBasedPipelineStage(PdPipelineStage):
    &#34;&#34;&#34;A pipeline stage that operates on a subset of dataframe columns.

    Parameters
    ---------
    columns : object, iterable or callable
        The label, or an iterable of labels, of columns to use. Alternatively,
        this parameter can be assigned a callable returning an iterable of
        labels from an input pandas.DataFrame. See pdpipe.cq.
    exclude_columns : object, iterable or callable, optional
        The label, or an iterable of labels, of columns to exclude, given the
        `columns` parameter. Alternatively, this parameter can be assigned a
        callable returning a labels iterable from an input pandas.DataFrame.
        See pdpipe.cq. Optional. By default no columns are excluded.
    desc_temp : str, optional
        If given, assumed to be a format string, and every appearance of {} in
        it is replaced with an appropriate string representation of the columns
        parameter, and is used as the pipeline description. Ignored if `desc`
        is provided.
    none_columns : iterable, callable or str, default &#39;error&#39;
        Determines how None values supplied to the &#39;columns&#39; parameter should
        be handled. If set to &#39;error&#39;, the default, a ValueError is raised if
        None is encountered. If set to &#39;all&#39;, it is interpreted to mean all
        columns of input dataframes should be operated on. If an iterable is
        provided it is interpreted as the default list of columns to operate on
        when `columns=None`. If a callable is provided, it is interpreted as
        the default column qualifier that determines input columns when
        `columns=None`.
    **kwargs
        Additionally supports all constructor parameters of PdPipelineStage.
    &#34;&#34;&#34;

    @staticmethod
    def _interpret_columns_param(columns, none_error=False, none_columns=None):
        &#34;&#34;&#34;Interprets the value provided to the columns parameter and returns
        a list version of it - if needed - a string representation of it.
        &#34;&#34;&#34;
        if columns is None:
            if none_error:
                raise ValueError((
                    &#39;None is not a valid argument for the columns parameter of&#39;
                    &#39; this pipeline stage.&#39;))
            return ColumnsBasedPipelineStage._interpret_columns_param(
                columns=none_columns)
        if isinstance(columns, str):
            # always check str first, because it has __iter__
            return [columns], columns
        if callable(columns):
            # if isinstance(columns, ColumnQualifier):
            #     return columns, columns.__repr__() or &#39;&#39;
            return columns, columns.__doc__ or &#39;&#39;
        # if it was a single string it was already made a list, and it&#39;s not a
        # callable, so it&#39;s either an iterable of labels... or
        if hasattr(columns, &#39;__iter__&#39;):
            return columns, &#39;, &#39;.join(str(elem) for elem in columns)
        # a single non-string label.
        return [columns], str(columns)

    def __init__(
            self, columns, exclude_columns=None, desc_temp=None,
            none_columns=&#39;error&#39;, **kwargs):
        self._exclude_columns = exclude_columns
        if exclude_columns:
            self._exclude_columns = self._interpret_columns_param(
                exclude_columns)
        self._none_error = False
        self._none_cols = None
        # handle none_columns
        if isinstance(none_columns, str):
            if none_columns == &#39;error&#39;:
                self._none_error = True
            elif none_columns == &#39;all&#39;:
                self._none_cols = AllColumns()
            else:
                raise ValueError((
                    &#34;&#39;error&#39; and &#39;all&#39; are the only valid string arguments&#34;
                    &#34; to the none_columns constructor parameter!&#34;))
        elif hasattr(none_columns, &#39;__iter__&#39;):
            self._none_cols = none_columns
        elif callable(none_columns):
            self._none_cols = none_columns
        else:
            raise ValueError((
                &#34;Valid arguments to the none_columns constructor parameter&#34;
                &#34; are &#39;error&#39;, &#39;all&#39;, an iterable of labels or a callable!&#34;
            ))
        # done handling none_columns
        self._col_arg, self._col_str = self._interpret_columns_param(
            columns, self._none_error, none_columns=self._none_cols)
        if (kwargs.get(&#39;desc&#39;) is None) and desc_temp:
            kwargs[&#39;desc&#39;] = desc_temp.format(self._col_str)
        if kwargs.get(&#39;exmsg&#39;) is None:
            kwargs[&#39;exmsg&#39;] = (
                &#39;Pipeline stage failed because not all columns {} &#39;
                &#39;were found in the input dataframe.&#39;
            ).format(self._col_str)
        super().__init__(**kwargs)

    def _is_fittable(self):
        return is_fittable_column_qualifier(self._col_arg)

    @staticmethod
    def __get_cols_by_arg(col_arg, df, fit=False):
        try:
            if fit:
                # try to treat col_arg as a fittable column qualifier
                return col_arg.fit_transform(df)
            # else, no need to fit, so try to treat _col_arg as a callable
            return col_arg(df)
        except AttributeError:
            # got here cause col_arg has no fit_transform method...
            try:
                # so try and treat it as a callable again
                return col_arg(df)
            except TypeError:
                # calling col_arg 2 lines above failed; its a list of labels
                return col_arg
        except TypeError:
            # calling _col_arg 10 lines above failed; its a list of labels
            return col_arg

    def _get_columns(self, df, fit=False):
        cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
            self._col_arg, df, fit=fit)
        if self._exclude_columns:
            exc_cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
                self._exclude_columns, df, fit=fit)
            return [x for x in cols if x not in exc_cols]
        return cols

    def _prec(self, df):
        return set(self._get_columns(df=df)).issubset(df.columns)

    @abc.abstractmethod
    def _transformation(self, df, verbose, fit):
        raise NotImplementedError((
            &#34;Classes extending ColumnsBasedPipelineStage must implement the &#34;
            &#34;_transformation method!&#34;))

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        return self._transformation(df, verbose, fit=True)

    def _transform(self, df, verbose):
        return self._transformation(df, verbose, fit=False)


def _always_true(x):
    return True


class AdHocStage(PdPipelineStage):
    &#34;&#34;&#34;An ad-hoc stage of a pandas DataFrame-processing pipeline.

    The signature for both the `transform` and the optional `fit_transform`
    callables is adaptive: The first argument is used positionally (so no
    specific name is assumed or used) to supply the callable with the pandas
    DataFrame object to transform. The following additional keyword arguments
    are supplied if the are included in the callable&#39;s signature:
    `verbose` - Passed on from pdpipe&#39;s `fit`, `fit_transform`
    and `apply` methods.
    `fit_context` and `application_context` - Provides fit-specific and
    application-specific contexts, in the form of PdpApplicationContext
    objects, usually available to pipeline stages using `self.fit_context` and
    `self.application_context`.

    Parameters
    ----------
    transform : callable
        The transformation this stage applies to dataframes. If the
        fit_transform parameter is also populated than this transformation is
        only applied on calls to transform. See documentation for the exact
        signature.
    fit_transform : callable, optional
        The transformation this stage applies to dataframes, only on
        fit_transform. Optional. See documentation for the exact signature.
    prec : callable, default None
        A callable that returns a boolean value. Represent a a precondition
        used to determine whether this stage can be applied to a given
        dataframe. If None is given, set to a function always returning True.
    &#34;&#34;&#34;

    def __init__(self, transform, fit_transform=None, prec=None, **kwargs):
        if prec is None:
            prec = _always_true
        self._adhoc_transform = transform
        self._adhoc_fit_transform = fit_transform
        self._adhoc_prec = prec
        self._transform_kwargs = _get_args_list(self._adhoc_transform)
        try:
            self._fit_transform_kwargs = _get_args_list(
                self._adhoc_fit_transform)
        except TypeError:  # fit_transform is None
            self._fit_transform_kwargs = {}
        super().__init__(**kwargs)

    def _prec(self, df):
        return self._adhoc_prec(df)

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        if self._adhoc_fit_transform is None:
            self.is_fitted = True
            return self._transform(df, verbose)
        kwargs = {
            &#39;verbose&#39;: verbose,
            &#39;fit_context&#39;: self.fit_context,
            &#39;application_context&#39;: self.application_context,
        }
        kwargs = {
            k: v for k, v in kwargs.items() if k in self._fit_transform_kwargs}
        return self._adhoc_fit_transform(df, **kwargs)

    def _transform(self, df, verbose):
        kwargs = {
            &#39;verbose&#39;: verbose,
            &#39;fit_context&#39;: self.fit_context,
            &#39;application_context&#39;: self.application_context,
        }
        kwargs = {
            k: v for k, v in kwargs.items() if k in self._transform_kwargs}
        return self._adhoc_transform(df, **kwargs)


class PdPipeline(PdPipelineStage, collections.abc.Sequence):
    &#34;&#34;&#34;A pipeline for processing pandas DataFrame objects.

    transformer_getter is usefull to avoid applying pipeline stages that are
    aimed to filter out items in a big dataset to create a training set for a
    machine learning model, for example, but should not be applied on future
    individual items to be transformed by the fitted pipeline.

    Parameters
    ----------
    stages : list
        A list of PdPipelineStage objects making up this pipeline.
    transform_getter : callable, optional
        A callable that can be applied to the fitted pipeline to produce a
        sub-pipeline of it which should be used to transform dataframes after
        the pipeline has been fitted. If not given, the fitted pipeline is used
        entirely.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Pipeline precondition failed!&#39;

    def __init__(self, stages, transformer_getter=None, **kwargs):
        self._stages = stages
        self._trans_getter = transformer_getter
        self.is_fitted = False
        super_kwargs = {
            &#39;exraise&#39;: False,
            &#39;exmsg&#39;: PdPipeline._DEF_EXC_MSG,
        }
        super_kwargs.update(**kwargs)
        super().__init__(**super_kwargs)

    # implementing a collections.abc.Sequence abstract method
    def __getitem__(self, index):
        if isinstance(index, slice):
            return PdPipeline(self._stages[index])

        if isinstance(index, list) and all(isinstance(x, str) for x in index):
            stages = [stage for stage in self._stages if stage._name in index]
            return PdPipeline(stages)

        if isinstance(index, str):
            stages = [stage for stage in self._stages if stage._name == index]
            if len(stages) == 0:
                raise ValueError(f&#34;&#39;{index}&#39; is not exist.&#34;)
            return stages[0]

        return self._stages[index]

    # implementing a collections.abc.Sequence abstract method
    def __len__(self):
        return len(self._stages)

    def _prec(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _post(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _transform(self, df, verbose):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _post_transform_lock(self):
        self.application_context.lock()
        self.fit_context.lock()

    def apply(self, df, exraise=None, verbose=False):
        self.application_context = PdpApplicationContext()
        if self.is_fitted:
            res = self.transform(X=df, exraise=exraise, verbose=verbose)
            self._post_transform_lock()
            return res
        self.fit_context = PdpApplicationContext()
        res = self.fit_transform(X=df, exraise=exraise, verbose=verbose)
        self._post_transform_lock()
        return res

    def __timed_fit_transform(self, X, y=None, exraise=None, verbose=None):
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        inter_x = X
        times = []
        prev = time.time()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.fit_transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
                now = time.time()
                times.append(now - prev)
                prev = now
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self.is_fitted = True
        print(&#34;\nPipeline total application time: {:.3f}s.\n Details:&#34;.format(
            sum(times)))
        print(self.__times_str__(times))
        self._post_transform_lock()
        return inter_x

    def fit_transform(self, X, y=None, exraise=None, verbose=None, time=False):
        &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The resulting dacaframe.
        &#34;&#34;&#34;
        if time:
            return self.__timed_fit_transform(
                X=X, y=y, exraise=exraise, verbose=verbose)
        inter_x = X
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.fit_transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self._post_transform_lock()
        self.is_fitted = True
        return inter_x

    def fit(self, X, y=None, exraise=None, verbose=None, time=None):
        &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The input dataframe, unchanged.
        &#34;&#34;&#34;
        self.fit_transform(
            X=X,
            y=None,
            exraise=exraise,
            verbose=verbose,
            time=time,
        )
        return X

    def __timed_transform(self, X, y=None, exraise=None, verbose=None):
        inter_x = X
        times = []
        prev = time.time()
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
                now = time.time()
                times.append(now - prev)
                prev = now
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self.is_fitted = True
        print(&#34;\nPipeline total application time: {:.3f}s.\n Details:&#34;.format(
            sum(times)))
        print(self.__times_str__(times))
        self._post_transform_lock()
        return inter_x

    def transform(self, X, y=None, exraise=None, verbose=None, time=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

        If any stage in this pipeline is fittable but is not fitted, an
        UnfittedPipelineStageError is raised before transformation starts.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        for stage in self._stages:
            if stage._is_fittable() and not stage.is_fitted:
                raise UnfittedPipelineStageError((
                    &#34;PipelineStage {} in pipeline is fittable but&#34;
                    &#34; unfitted!&#34;).format(stage))
        if time:
            return self.__timed_transform(
                X=X, y=y, exraise=exraise, verbose=verbose)
        inter_df = X
        self.application_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.application_context = self.application_context
                inter_df = stage.transform(
                    X=inter_df,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self._post_transform_lock()
        return inter_df

    __call__ = apply

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([*self._stages, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([*self._stages, other])
        return NotImplemented

    def __times_str__(self, times):
        res = &#34;A pdpipe pipeline:\n&#34;
        stime = sum(times)
        if stime &gt; 0:  # pragma: no cover
            percentages = [100 * x / stime for x in times]
        else:  # pragma: no cover
            percentages = [0 for x in times]
        res += &#39;[ 0] [{:0&gt;5.2f}s ({:0&gt;5.2f}%)]  &#39;.format(
            times[0], percentages[0]
        ) + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())
        ) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}] [{:0&gt;5.2f}s ({:0&gt;5.2f}%)]  &#39;.format(
                i + 1, times[i + 1], percentages[i + 1]
            ) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())
            ) + &#39;\n&#39;
        return res

    def __str__(self):
        res = &#34;A pdpipe pipeline:\n&#34;
        res += &#39;[ 0]  &#39; + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}]  &#39;.format(i + 1) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())) + &#39;\n&#39;
        return res

    def _mem_str(self, total):
        total = asizeof(self)
        lines = []
        for i, stage in enumerate(self._stages):
            size = asizeof(stage)
            if size &gt; 500000:  # pragma: no cover
                lines.append(&#39;[{:&gt;2}] {:.2f}Mb ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size / 1000000, 100 * size / total,
                    stage.description()))
            elif size &gt; 1000:  # pragma: no cover
                lines.append(&#39;[{:&gt;2}] {:.2f}Kb ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size / 1000, 100 * size / total, stage.description()))
            else:
                lines.append(&#39;[{:&gt;2}] {:}b ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size, 100 * size / total, stage.description()))
            lines.append(stage._mem_str())
        return &#39;&#39;.join(lines)

    def memory_report(self):
        &#34;&#34;&#34;Prints a detailed memory report of the pipeline object to screen.

        To get better memory estimates make sure the pympler Python package is
        installed. Without it, sys.getsizeof is used, which can be extremely
        underestimate memory size of Python objects.
        &#34;&#34;&#34;
        print(&#34;=== Pipeline memory report ===&#34;)
        size = asizeof(self)
        if size &gt; 500000:  # pragma: no cover
            print(&#34;Total pipeline size in memory: {:.2f}Mb&#34;.format(
                size / 1000000))
        elif size &gt; 1000:  # pragma: no cover
            print(&#34;Total pipeline size in memory: {:.2f}Kb&#34;.format(
                size / 1000))
        else:
            print(&#34;Total pipeline size in memory: {:.2f}b&#34;.format(
                size))
        print(&#34;Per-stage memory structure:&#34;)
        print(self._mem_str(total=size))

    def get_transformer(self):
        &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

           This transformer is a `pdpipe` pipeline that transforms input data
           in a way corresponding to this pipline after it has been fitted. By
           default this is the pipeline itself, but the `transform_getter`
           constructor parameter can be used to return a sub-pipeline of the
           fitted pipeline instead, for cases where some stages should only be
           applied when fitting this pipeline to data.

        Returns
        -------
        pdpipe.PdPipeline
            The corresponding transformer pipeline induced by this pipeline.
        &#34;&#34;&#34;
        try:
            return self._trans_getter(self)
        except TypeError:  # pragma: no cover
            return self

    # def drop(self, index):
    #     &#34;&#34;&#34;Returns this pipeline with the stage of the given index removed.
    #     Arguments
    #     ---------
    #     index


def make_pdpipeline(*stages):
    &#34;&#34;&#34;Constructs a PdPipeline from the given pipeline stages.

    Parameters
    ----------
    *stages : pdpipe.PipelineStage objects
       PdPipeline stages given as positional arguments.

    Returns
    -------
    p : pdpipe.PdPipeline
        The resulting pipeline.

    Examples
    --------
    import pdpipe as pdp
    make_pdpipeline(pdp.ColDrop(&#39;a&#39;), pdp.Bin(&#39;speed&#39;))
    &#34;&#34;&#34;
    return PdPipeline(stages=stages)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdpipe.core.make_pdpipeline"><code class="name flex">
<span>def <span class="ident">make_pdpipeline</span></span>(<span>*stages)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a PdPipeline from the given pipeline stages.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*stages</code></strong> :&ensp;<code>pdpipe.PipelineStage objects</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>PdPipeline stages given as positional arguments.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>pdpipe.PdPipeline</code></dt>
<dd>The resulting pipeline.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>import pdpipe as pdp
make_pdpipeline(pdp.ColDrop('a'), pdp.Bin('speed'))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_pdpipeline(*stages):
    &#34;&#34;&#34;Constructs a PdPipeline from the given pipeline stages.

    Parameters
    ----------
    *stages : pdpipe.PipelineStage objects
       PdPipeline stages given as positional arguments.

    Returns
    -------
    p : pdpipe.PdPipeline
        The resulting pipeline.

    Examples
    --------
    import pdpipe as pdp
    make_pdpipeline(pdp.ColDrop(&#39;a&#39;), pdp.Bin(&#39;speed&#39;))
    &#34;&#34;&#34;
    return PdPipeline(stages=stages)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdpipe.core.AdHocStage"><code class="flex name class">
<span>class <span class="ident">AdHocStage</span></span>
<span>(</span><span>transform, fit_transform=None, prec=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An ad-hoc stage of a pandas DataFrame-processing pipeline.</p>
<p>The signature for both the <code>transform</code> and the optional <code>fit_transform</code>
callables is adaptive: The first argument is used positionally (so no
specific name is assumed or used) to supply the callable with the pandas
DataFrame object to transform. The following additional keyword arguments
are supplied if the are included in the callable's signature:
<code>verbose</code> - Passed on from pdpipe's <code>fit</code>, <code>fit_transform</code>
and <code>apply</code> methods.
<code>fit_context</code> and <code>application_context</code> - Provides fit-specific and
application-specific contexts, in the form of PdpApplicationContext
objects, usually available to pipeline stages using <code>self.fit_context</code> and
<code>self.application_context</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code></dt>
<dd>The transformation this stage applies to dataframes. If the
fit_transform parameter is also populated than this transformation is
only applied on calls to transform. See documentation for the exact
signature.</dd>
<dt><strong><code>fit_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>The transformation this stage applies to dataframes, only on
fit_transform. Optional. See documentation for the exact signature.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>A callable that returns a boolean value. Represent a a precondition
used to determine whether this stage can be applied to a given
dataframe. If None is given, set to a function always returning True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdHocStage(PdPipelineStage):
    &#34;&#34;&#34;An ad-hoc stage of a pandas DataFrame-processing pipeline.

    The signature for both the `transform` and the optional `fit_transform`
    callables is adaptive: The first argument is used positionally (so no
    specific name is assumed or used) to supply the callable with the pandas
    DataFrame object to transform. The following additional keyword arguments
    are supplied if the are included in the callable&#39;s signature:
    `verbose` - Passed on from pdpipe&#39;s `fit`, `fit_transform`
    and `apply` methods.
    `fit_context` and `application_context` - Provides fit-specific and
    application-specific contexts, in the form of PdpApplicationContext
    objects, usually available to pipeline stages using `self.fit_context` and
    `self.application_context`.

    Parameters
    ----------
    transform : callable
        The transformation this stage applies to dataframes. If the
        fit_transform parameter is also populated than this transformation is
        only applied on calls to transform. See documentation for the exact
        signature.
    fit_transform : callable, optional
        The transformation this stage applies to dataframes, only on
        fit_transform. Optional. See documentation for the exact signature.
    prec : callable, default None
        A callable that returns a boolean value. Represent a a precondition
        used to determine whether this stage can be applied to a given
        dataframe. If None is given, set to a function always returning True.
    &#34;&#34;&#34;

    def __init__(self, transform, fit_transform=None, prec=None, **kwargs):
        if prec is None:
            prec = _always_true
        self._adhoc_transform = transform
        self._adhoc_fit_transform = fit_transform
        self._adhoc_prec = prec
        self._transform_kwargs = _get_args_list(self._adhoc_transform)
        try:
            self._fit_transform_kwargs = _get_args_list(
                self._adhoc_fit_transform)
        except TypeError:  # fit_transform is None
            self._fit_transform_kwargs = {}
        super().__init__(**kwargs)

    def _prec(self, df):
        return self._adhoc_prec(df)

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        if self._adhoc_fit_transform is None:
            self.is_fitted = True
            return self._transform(df, verbose)
        kwargs = {
            &#39;verbose&#39;: verbose,
            &#39;fit_context&#39;: self.fit_context,
            &#39;application_context&#39;: self.application_context,
        }
        kwargs = {
            k: v for k, v in kwargs.items() if k in self._fit_transform_kwargs}
        return self._adhoc_fit_transform(df, **kwargs)

    def _transform(self, df, verbose):
        kwargs = {
            &#39;verbose&#39;: verbose,
            &#39;fit_context&#39;: self.fit_context,
            &#39;application_context&#39;: self.application_context,
        }
        kwargs = {
            k: v for k, v in kwargs.items() if k in self._transform_kwargs}
        return self._adhoc_transform(df, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer" href="#pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer">ColumnDtypeEnforcer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ConditionValidator" href="#pdpipe.core.PdPipelineStage.ConditionValidator">ConditionValidator</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SetIndex" href="#pdpipe.core.PdPipelineStage.SetIndex">SetIndex</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.ColumnsBasedPipelineStage"><code class="flex name class">
<span>class <span class="ident">ColumnsBasedPipelineStage</span></span>
<span>(</span><span>columns, exclude_columns=None, desc_temp=None, none_columns='error', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline stage that operates on a subset of dataframe columns.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to use. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
<dt><strong><code>desc_temp</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If given, assumed to be a format string, and every appearance of {} in
it is replaced with an appropriate string representation of the columns
parameter, and is used as the pipeline description. Ignored if <code>desc</code>
is provided.</dd>
<dt><strong><code>none_columns</code></strong> :&ensp;<code>iterable, callable</code> or <code>str</code>, default <code>'error'</code></dt>
<dd>Determines how None values supplied to the 'columns' parameter should
be handled. If set to 'error', the default, a ValueError is raised if
None is encountered. If set to 'all', it is interpreted to mean all
columns of input dataframes should be operated on. If an iterable is
provided it is interpreted as the default list of columns to operate on
when <code>columns=None</code>. If a callable is provided, it is interpreted as
the default column qualifier that determines input columns when
<code>columns=None</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionally supports all constructor parameters of PdPipelineStage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnsBasedPipelineStage(PdPipelineStage):
    &#34;&#34;&#34;A pipeline stage that operates on a subset of dataframe columns.

    Parameters
    ---------
    columns : object, iterable or callable
        The label, or an iterable of labels, of columns to use. Alternatively,
        this parameter can be assigned a callable returning an iterable of
        labels from an input pandas.DataFrame. See pdpipe.cq.
    exclude_columns : object, iterable or callable, optional
        The label, or an iterable of labels, of columns to exclude, given the
        `columns` parameter. Alternatively, this parameter can be assigned a
        callable returning a labels iterable from an input pandas.DataFrame.
        See pdpipe.cq. Optional. By default no columns are excluded.
    desc_temp : str, optional
        If given, assumed to be a format string, and every appearance of {} in
        it is replaced with an appropriate string representation of the columns
        parameter, and is used as the pipeline description. Ignored if `desc`
        is provided.
    none_columns : iterable, callable or str, default &#39;error&#39;
        Determines how None values supplied to the &#39;columns&#39; parameter should
        be handled. If set to &#39;error&#39;, the default, a ValueError is raised if
        None is encountered. If set to &#39;all&#39;, it is interpreted to mean all
        columns of input dataframes should be operated on. If an iterable is
        provided it is interpreted as the default list of columns to operate on
        when `columns=None`. If a callable is provided, it is interpreted as
        the default column qualifier that determines input columns when
        `columns=None`.
    **kwargs
        Additionally supports all constructor parameters of PdPipelineStage.
    &#34;&#34;&#34;

    @staticmethod
    def _interpret_columns_param(columns, none_error=False, none_columns=None):
        &#34;&#34;&#34;Interprets the value provided to the columns parameter and returns
        a list version of it - if needed - a string representation of it.
        &#34;&#34;&#34;
        if columns is None:
            if none_error:
                raise ValueError((
                    &#39;None is not a valid argument for the columns parameter of&#39;
                    &#39; this pipeline stage.&#39;))
            return ColumnsBasedPipelineStage._interpret_columns_param(
                columns=none_columns)
        if isinstance(columns, str):
            # always check str first, because it has __iter__
            return [columns], columns
        if callable(columns):
            # if isinstance(columns, ColumnQualifier):
            #     return columns, columns.__repr__() or &#39;&#39;
            return columns, columns.__doc__ or &#39;&#39;
        # if it was a single string it was already made a list, and it&#39;s not a
        # callable, so it&#39;s either an iterable of labels... or
        if hasattr(columns, &#39;__iter__&#39;):
            return columns, &#39;, &#39;.join(str(elem) for elem in columns)
        # a single non-string label.
        return [columns], str(columns)

    def __init__(
            self, columns, exclude_columns=None, desc_temp=None,
            none_columns=&#39;error&#39;, **kwargs):
        self._exclude_columns = exclude_columns
        if exclude_columns:
            self._exclude_columns = self._interpret_columns_param(
                exclude_columns)
        self._none_error = False
        self._none_cols = None
        # handle none_columns
        if isinstance(none_columns, str):
            if none_columns == &#39;error&#39;:
                self._none_error = True
            elif none_columns == &#39;all&#39;:
                self._none_cols = AllColumns()
            else:
                raise ValueError((
                    &#34;&#39;error&#39; and &#39;all&#39; are the only valid string arguments&#34;
                    &#34; to the none_columns constructor parameter!&#34;))
        elif hasattr(none_columns, &#39;__iter__&#39;):
            self._none_cols = none_columns
        elif callable(none_columns):
            self._none_cols = none_columns
        else:
            raise ValueError((
                &#34;Valid arguments to the none_columns constructor parameter&#34;
                &#34; are &#39;error&#39;, &#39;all&#39;, an iterable of labels or a callable!&#34;
            ))
        # done handling none_columns
        self._col_arg, self._col_str = self._interpret_columns_param(
            columns, self._none_error, none_columns=self._none_cols)
        if (kwargs.get(&#39;desc&#39;) is None) and desc_temp:
            kwargs[&#39;desc&#39;] = desc_temp.format(self._col_str)
        if kwargs.get(&#39;exmsg&#39;) is None:
            kwargs[&#39;exmsg&#39;] = (
                &#39;Pipeline stage failed because not all columns {} &#39;
                &#39;were found in the input dataframe.&#39;
            ).format(self._col_str)
        super().__init__(**kwargs)

    def _is_fittable(self):
        return is_fittable_column_qualifier(self._col_arg)

    @staticmethod
    def __get_cols_by_arg(col_arg, df, fit=False):
        try:
            if fit:
                # try to treat col_arg as a fittable column qualifier
                return col_arg.fit_transform(df)
            # else, no need to fit, so try to treat _col_arg as a callable
            return col_arg(df)
        except AttributeError:
            # got here cause col_arg has no fit_transform method...
            try:
                # so try and treat it as a callable again
                return col_arg(df)
            except TypeError:
                # calling col_arg 2 lines above failed; its a list of labels
                return col_arg
        except TypeError:
            # calling _col_arg 10 lines above failed; its a list of labels
            return col_arg

    def _get_columns(self, df, fit=False):
        cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
            self._col_arg, df, fit=fit)
        if self._exclude_columns:
            exc_cols = ColumnsBasedPipelineStage.__get_cols_by_arg(
                self._exclude_columns, df, fit=fit)
            return [x for x in cols if x not in exc_cols]
        return cols

    def _prec(self, df):
        return set(self._get_columns(df=df)).issubset(df.columns)

    @abc.abstractmethod
    def _transformation(self, df, verbose, fit):
        raise NotImplementedError((
            &#34;Classes extending ColumnsBasedPipelineStage must implement the &#34;
            &#34;_transformation method!&#34;))

    def _fit_transform(self, df, verbose):
        self.is_fitted = True
        return self._transformation(df, verbose, fit=True)

    def _transform(self, df, verbose):
        return self._transformation(df, verbose, fit=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.basic_stages.ColDrop" href="basic_stages.html#pdpipe.basic_stages.ColDrop">ColDrop</a></li>
<li><a title="pdpipe.basic_stages.DropDuplicates" href="basic_stages.html#pdpipe.basic_stages.DropDuplicates">DropDuplicates</a></li>
<li><a title="pdpipe.basic_stages.RowDrop" href="basic_stages.html#pdpipe.basic_stages.RowDrop">RowDrop</a></li>
<li><a title="pdpipe.basic_stages.ValDrop" href="basic_stages.html#pdpipe.basic_stages.ValDrop">ValDrop</a></li>
<li><a title="pdpipe.basic_stages.ValKeep" href="basic_stages.html#pdpipe.basic_stages.ValKeep">ValKeep</a></li>
<li><a title="pdpipe.col_generation.ColumnTransformer" href="col_generation.html#pdpipe.col_generation.ColumnTransformer">ColumnTransformer</a></li>
<li><a title="pdpipe.col_generation.Log" href="col_generation.html#pdpipe.col_generation.Log">Log</a></li>
<li><a title="pdpipe.col_generation.OneHotEncode" href="col_generation.html#pdpipe.col_generation.OneHotEncode">OneHotEncode</a></li>
<li><a title="pdpipe.nltk_stages.DropRareTokens" href="nltk_stages.html#pdpipe.nltk_stages.DropRareTokens">DropRareTokens</a></li>
<li><a title="pdpipe.sklearn_stages.Encode" href="sklearn_stages.html#pdpipe.sklearn_stages.Encode">Encode</a></li>
<li><a title="pdpipe.sklearn_stages.Scale" href="sklearn_stages.html#pdpipe.sklearn_stages.Scale">Scale</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer" href="#pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer">ColumnDtypeEnforcer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ConditionValidator" href="#pdpipe.core.PdPipelineStage.ConditionValidator">ConditionValidator</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SetIndex" href="#pdpipe.core.PdPipelineStage.SetIndex">SetIndex</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.PdPipeline"><code class="flex name class">
<span>class <span class="ident">PdPipeline</span></span>
<span>(</span><span>stages, transformer_getter=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline for processing pandas DataFrame objects.</p>
<p>transformer_getter is usefull to avoid applying pipeline stages that are
aimed to filter out items in a big dataset to create a training set for a
machine learning model, for example, but should not be applied on future
individual items to be transformed by the fitted pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stages</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of PdPipelineStage objects making up this pipeline.</dd>
<dt><strong><code>transform_getter</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callable that can be applied to the fitted pipeline to produce a
sub-pipeline of it which should be used to transform dataframes after
the pipeline has been fitted. If not given, the fitted pipeline is used
entirely.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdPipeline(PdPipelineStage, collections.abc.Sequence):
    &#34;&#34;&#34;A pipeline for processing pandas DataFrame objects.

    transformer_getter is usefull to avoid applying pipeline stages that are
    aimed to filter out items in a big dataset to create a training set for a
    machine learning model, for example, but should not be applied on future
    individual items to be transformed by the fitted pipeline.

    Parameters
    ----------
    stages : list
        A list of PdPipelineStage objects making up this pipeline.
    transform_getter : callable, optional
        A callable that can be applied to the fitted pipeline to produce a
        sub-pipeline of it which should be used to transform dataframes after
        the pipeline has been fitted. If not given, the fitted pipeline is used
        entirely.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Pipeline precondition failed!&#39;

    def __init__(self, stages, transformer_getter=None, **kwargs):
        self._stages = stages
        self._trans_getter = transformer_getter
        self.is_fitted = False
        super_kwargs = {
            &#39;exraise&#39;: False,
            &#39;exmsg&#39;: PdPipeline._DEF_EXC_MSG,
        }
        super_kwargs.update(**kwargs)
        super().__init__(**super_kwargs)

    # implementing a collections.abc.Sequence abstract method
    def __getitem__(self, index):
        if isinstance(index, slice):
            return PdPipeline(self._stages[index])

        if isinstance(index, list) and all(isinstance(x, str) for x in index):
            stages = [stage for stage in self._stages if stage._name in index]
            return PdPipeline(stages)

        if isinstance(index, str):
            stages = [stage for stage in self._stages if stage._name == index]
            if len(stages) == 0:
                raise ValueError(f&#34;&#39;{index}&#39; is not exist.&#34;)
            return stages[0]

        return self._stages[index]

    # implementing a collections.abc.Sequence abstract method
    def __len__(self):
        return len(self._stages)

    def _prec(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _post(self, df):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _transform(self, df, verbose):
        # PdPipeline overrides apply in a way which makes this moot
        raise NotImplementedError

    def _post_transform_lock(self):
        self.application_context.lock()
        self.fit_context.lock()

    def apply(self, df, exraise=None, verbose=False):
        self.application_context = PdpApplicationContext()
        if self.is_fitted:
            res = self.transform(X=df, exraise=exraise, verbose=verbose)
            self._post_transform_lock()
            return res
        self.fit_context = PdpApplicationContext()
        res = self.fit_transform(X=df, exraise=exraise, verbose=verbose)
        self._post_transform_lock()
        return res

    def __timed_fit_transform(self, X, y=None, exraise=None, verbose=None):
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        inter_x = X
        times = []
        prev = time.time()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.fit_transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
                now = time.time()
                times.append(now - prev)
                prev = now
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self.is_fitted = True
        print(&#34;\nPipeline total application time: {:.3f}s.\n Details:&#34;.format(
            sum(times)))
        print(self.__times_str__(times))
        self._post_transform_lock()
        return inter_x

    def fit_transform(self, X, y=None, exraise=None, verbose=None, time=False):
        &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The resulting dacaframe.
        &#34;&#34;&#34;
        if time:
            return self.__timed_fit_transform(
                X=X, y=y, exraise=exraise, verbose=verbose)
        inter_x = X
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.fit_transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self._post_transform_lock()
        self.is_fitted = True
        return inter_x

    def fit(self, X, y=None, exraise=None, verbose=None, time=None):
        &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to fit this pipeline by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The input dataframe, unchanged.
        &#34;&#34;&#34;
        self.fit_transform(
            X=X,
            y=None,
            exraise=exraise,
            verbose=verbose,
            time=time,
        )
        return X

    def __timed_transform(self, X, y=None, exraise=None, verbose=None):
        inter_x = X
        times = []
        prev = time.time()
        self.application_context = PdpApplicationContext()
        self.fit_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.fit_context = self.fit_context
                stage.application_context = self.application_context
                inter_x = stage.transform(
                    X=inter_x,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
                now = time.time()
                times.append(now - prev)
                prev = now
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self.is_fitted = True
        print(&#34;\nPipeline total application time: {:.3f}s.\n Details:&#34;.format(
            sum(times)))
        print(self.__times_str__(times))
        self._post_transform_lock()
        return inter_x

    def transform(self, X, y=None, exraise=None, verbose=None, time=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

        If any stage in this pipeline is fittable but is not fitted, an
        UnfittedPipelineStageError is raised before transformation starts.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Determines behaviour if the precondition of composing stages is not
            fulfilled by the input dataframe: If True, a
            pdpipe.FailedPreconditionError is raised. If False, the stage is
            skipped. If not given, or set to None, the default behaviour of
            each stage is used, as determined by its &#39;exraise&#39; constructor
            parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            of each stage is checked but before its application. Otherwise, no
            messages are printed.
        time : bool, default False
            If True, per-stage application time is measured and reported when
            pipeline application is done.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        for stage in self._stages:
            if stage._is_fittable() and not stage.is_fitted:
                raise UnfittedPipelineStageError((
                    &#34;PipelineStage {} in pipeline is fittable but&#34;
                    &#34; unfitted!&#34;).format(stage))
        if time:
            return self.__timed_transform(
                X=X, y=y, exraise=exraise, verbose=verbose)
        inter_df = X
        self.application_context = PdpApplicationContext()
        for i, stage in enumerate(self._stages):
            try:
                stage.application_context = self.application_context
                inter_df = stage.transform(
                    X=inter_df,
                    y=None,
                    exraise=exraise,
                    verbose=verbose,
                )
            except Exception as e:
                raise PipelineApplicationError(
                    f&#34;Exception raised in stage [ {i}] {stage}&#34;
                ) from e
        self._post_transform_lock()
        return inter_df

    __call__ = apply

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([*self._stages, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([*self._stages, other])
        return NotImplemented

    def __times_str__(self, times):
        res = &#34;A pdpipe pipeline:\n&#34;
        stime = sum(times)
        if stime &gt; 0:  # pragma: no cover
            percentages = [100 * x / stime for x in times]
        else:  # pragma: no cover
            percentages = [0 for x in times]
        res += &#39;[ 0] [{:0&gt;5.2f}s ({:0&gt;5.2f}%)]  &#39;.format(
            times[0], percentages[0]
        ) + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())
        ) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}] [{:0&gt;5.2f}s ({:0&gt;5.2f}%)]  &#39;.format(
                i + 1, times[i + 1], percentages[i + 1]
            ) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())
            ) + &#39;\n&#39;
        return res

    def __str__(self):
        res = &#34;A pdpipe pipeline:\n&#34;
        res += &#39;[ 0]  &#39; + &#34;\n      &#34;.join(
            textwrap.wrap(self._stages[0].description())) + &#39;\n&#39;
        for i, stage in enumerate(self._stages[1:]):
            res += &#39;[{:&gt;2}]  &#39;.format(i + 1) + &#34;\n      &#34;.join(
                textwrap.wrap(stage.description())) + &#39;\n&#39;
        return res

    def _mem_str(self, total):
        total = asizeof(self)
        lines = []
        for i, stage in enumerate(self._stages):
            size = asizeof(stage)
            if size &gt; 500000:  # pragma: no cover
                lines.append(&#39;[{:&gt;2}] {:.2f}Mb ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size / 1000000, 100 * size / total,
                    stage.description()))
            elif size &gt; 1000:  # pragma: no cover
                lines.append(&#39;[{:&gt;2}] {:.2f}Kb ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size / 1000, 100 * size / total, stage.description()))
            else:
                lines.append(&#39;[{:&gt;2}] {:}b ({:0&gt;5.2f}%), {}\n&#39;.format(
                    i, size, 100 * size / total, stage.description()))
            lines.append(stage._mem_str())
        return &#39;&#39;.join(lines)

    def memory_report(self):
        &#34;&#34;&#34;Prints a detailed memory report of the pipeline object to screen.

        To get better memory estimates make sure the pympler Python package is
        installed. Without it, sys.getsizeof is used, which can be extremely
        underestimate memory size of Python objects.
        &#34;&#34;&#34;
        print(&#34;=== Pipeline memory report ===&#34;)
        size = asizeof(self)
        if size &gt; 500000:  # pragma: no cover
            print(&#34;Total pipeline size in memory: {:.2f}Mb&#34;.format(
                size / 1000000))
        elif size &gt; 1000:  # pragma: no cover
            print(&#34;Total pipeline size in memory: {:.2f}Kb&#34;.format(
                size / 1000))
        else:
            print(&#34;Total pipeline size in memory: {:.2f}b&#34;.format(
                size))
        print(&#34;Per-stage memory structure:&#34;)
        print(self._mem_str(total=size))

    def get_transformer(self):
        &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

           This transformer is a `pdpipe` pipeline that transforms input data
           in a way corresponding to this pipline after it has been fitted. By
           default this is the pipeline itself, but the `transform_getter`
           constructor parameter can be used to return a sub-pipeline of the
           fitted pipeline instead, for cases where some stages should only be
           applied when fitting this pipeline to data.

        Returns
        -------
        pdpipe.PdPipeline
            The corresponding transformer pipeline induced by this pipeline.
        &#34;&#34;&#34;
        try:
            return self._trans_getter(self)
        except TypeError:  # pragma: no cover
            return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></li>
<li>abc.ABC</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.core.PdPipeline.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None, exraise=None, verbose=None, time=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this pipeline without transforming the input dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to fit this pipeline by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, per-stage application time is measured and reported when
pipeline application is done.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The input dataframe, unchanged.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X, y=None, exraise=None, verbose=None, time=None):
    &#34;&#34;&#34;Fits this pipeline without transforming the input dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to fit this pipeline by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.
    time : bool, default False
        If True, per-stage application time is measured and reported when
        pipeline application is done.

    Returns
    -------
    pandas.DataFrame
        The input dataframe, unchanged.
    &#34;&#34;&#34;
    self.fit_transform(
        X=X,
        y=None,
        exraise=exraise,
        verbose=verbose,
        time=time,
    )
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.fit_transform"><code class="name flex">
<span>def <span class="ident">fit_transform</span></span>(<span>self, X, y=None, exraise=None, verbose=None, time=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this pipeline and transforms the input dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform and fit this pipeline by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, per-stage application time is measured and reported when
pipeline application is done.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dacaframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_transform(self, X, y=None, exraise=None, verbose=None, time=False):
    &#34;&#34;&#34;Fits this pipeline and transforms the input dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform and fit this pipeline by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.
    time : bool, default False
        If True, per-stage application time is measured and reported when
        pipeline application is done.

    Returns
    -------
    pandas.DataFrame
        The resulting dacaframe.
    &#34;&#34;&#34;
    if time:
        return self.__timed_fit_transform(
            X=X, y=y, exraise=exraise, verbose=verbose)
    inter_x = X
    self.application_context = PdpApplicationContext()
    self.fit_context = PdpApplicationContext()
    for i, stage in enumerate(self._stages):
        try:
            stage.fit_context = self.fit_context
            stage.application_context = self.application_context
            inter_x = stage.fit_transform(
                X=inter_x,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        except Exception as e:
            raise PipelineApplicationError(
                f&#34;Exception raised in stage [ {i}] {stage}&#34;
            ) from e
    self._post_transform_lock()
    self.is_fitted = True
    return inter_x</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.get_transformer"><code class="name flex">
<span>def <span class="ident">get_transformer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the transformer induced by this fitted pipeline.</p>
<p>This transformer is a <code><a title="pdpipe" href="index.html">pdpipe</a></code> pipeline that transforms input data
in a way corresponding to this pipline after it has been fitted. By
default this is the pipeline itself, but the <code>transform_getter</code>
constructor parameter can be used to return a sub-pipeline of the
fitted pipeline instead, for cases where some stages should only be
applied when fitting this pipeline to data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pdpipe.PdPipeline</code></dt>
<dd>The corresponding transformer pipeline induced by this pipeline.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transformer(self):
    &#34;&#34;&#34;Return the transformer induced by this fitted pipeline.

       This transformer is a `pdpipe` pipeline that transforms input data
       in a way corresponding to this pipline after it has been fitted. By
       default this is the pipeline itself, but the `transform_getter`
       constructor parameter can be used to return a sub-pipeline of the
       fitted pipeline instead, for cases where some stages should only be
       applied when fitting this pipeline to data.

    Returns
    -------
    pdpipe.PdPipeline
        The corresponding transformer pipeline induced by this pipeline.
    &#34;&#34;&#34;
    try:
        return self._trans_getter(self)
    except TypeError:  # pragma: no cover
        return self</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.memory_report"><code class="name flex">
<span>def <span class="ident">memory_report</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a detailed memory report of the pipeline object to screen.</p>
<p>To get better memory estimates make sure the pympler Python package is
installed. Without it, sys.getsizeof is used, which can be extremely
underestimate memory size of Python objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_report(self):
    &#34;&#34;&#34;Prints a detailed memory report of the pipeline object to screen.

    To get better memory estimates make sure the pympler Python package is
    installed. Without it, sys.getsizeof is used, which can be extremely
    underestimate memory size of Python objects.
    &#34;&#34;&#34;
    print(&#34;=== Pipeline memory report ===&#34;)
    size = asizeof(self)
    if size &gt; 500000:  # pragma: no cover
        print(&#34;Total pipeline size in memory: {:.2f}Mb&#34;.format(
            size / 1000000))
    elif size &gt; 1000:  # pragma: no cover
        print(&#34;Total pipeline size in memory: {:.2f}Kb&#34;.format(
            size / 1000))
    else:
        print(&#34;Total pipeline size in memory: {:.2f}b&#34;.format(
            size))
    print(&#34;Per-stage memory structure:&#34;)
    print(self._mem_str(total=size))</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipeline.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X, y=None, exraise=None, verbose=None, time=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given dataframe without fitting this pipeline.</p>
<p>If any stage in this pipeline is fittable but is not fitted, an
UnfittedPipelineStageError is raised before transformation starts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Determines behaviour if the precondition of composing stages is not
fulfilled by the input dataframe: If True, a
pdpipe.FailedPreconditionError is raised. If False, the stage is
skipped. If not given, or set to None, the default behaviour of
each stage is used, as determined by its 'exraise' constructor
parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
of each stage is checked but before its application. Otherwise, no
messages are printed.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, per-stage application time is measured and reported when
pipeline application is done.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X, y=None, exraise=None, verbose=None, time=False):
    &#34;&#34;&#34;Transforms the given dataframe without fitting this pipeline.

    If any stage in this pipeline is fittable but is not fitted, an
    UnfittedPipelineStageError is raised before transformation starts.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Determines behaviour if the precondition of composing stages is not
        fulfilled by the input dataframe: If True, a
        pdpipe.FailedPreconditionError is raised. If False, the stage is
        skipped. If not given, or set to None, the default behaviour of
        each stage is used, as determined by its &#39;exraise&#39; constructor
        parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        of each stage is checked but before its application. Otherwise, no
        messages are printed.
    time : bool, default False
        If True, per-stage application time is measured and reported when
        pipeline application is done.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    for stage in self._stages:
        if stage._is_fittable() and not stage.is_fitted:
            raise UnfittedPipelineStageError((
                &#34;PipelineStage {} in pipeline is fittable but&#34;
                &#34; unfitted!&#34;).format(stage))
    if time:
        return self.__timed_transform(
            X=X, y=y, exraise=exraise, verbose=verbose)
    inter_df = X
    self.application_context = PdpApplicationContext()
    for i, stage in enumerate(self._stages):
        try:
            stage.application_context = self.application_context
            inter_df = stage.transform(
                X=inter_df,
                y=None,
                exraise=exraise,
                verbose=verbose,
            )
        except Exception as e:
            raise PipelineApplicationError(
                f&#34;Exception raised in stage [ {i}] {stage}&#34;
            ) from e
    self._post_transform_lock()
    return inter_df</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></b></code>:
<ul class="hlist">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer" href="#pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer">ColumnDtypeEnforcer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ConditionValidator" href="#pdpipe.core.PdPipelineStage.ConditionValidator">ConditionValidator</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SetIndex" href="#pdpipe.core.PdPipelineStage.SetIndex">SetIndex</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pdpipe.core.PdPipelineStage"><code class="flex name class">
<span>class <span class="ident">PdPipelineStage</span></span>
<span>(</span><span>exraise=True, exmsg=None, desc=None, prec=None, post=None, skip=None, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>A stage of a pandas DataFrame-processing pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If true, a pdpipe.FailedPreconditionError is raised when this
stage is applied to a dataframe for which the precondition does
not hold. Otherwise the stage is skipped. Additionally, if true, a
pdpipe.FailedPostconditionError is raised if an expected post-codnition
does not hold for an output dataframe (after pipeline application).
Otherwise pipeline application continues uninterrupted.</dd>
<dt><strong><code>exmsg</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>The message of the exception that is raised on a failed
precondition if exraise is set to True. A default message is used
if None is given.</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A short description of this stage, used as its string representation.
A default description is used if None is given.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>This can be assigned a callable that returns boolean values for input
dataframes, which will be used to determine whether input dataframes
satisfy the preconditions for this pipeline stage (see the <code>exraise</code>
parameter for the behaviour of failed preconditions). See pdp.cond for
more information on specialised Condition objects.</dd>
<dt><strong><code>post</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>This can be assigned a callable that returns boolean values for input
dataframes, which will be used to determine whether input dataframes
satisfy the postconditions for this pipeline stage (see the <code>exraise</code>
parameter for the behaviour of failed postconditions). See pdp.cond for
more information on specialised Condition objects.</dd>
<dt><strong><code>skip</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>This can be assigned a callable that returns boolean values for input
dataframes, which will be used to determine whether this stage should
be skipped for input dataframes - if the callable returns True for an
input dataframe, this stage will be skipped. See pdp.cond for more
information on specialised Condition objects.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, default <code>''</code></dt>
<dd>The name of this stage. Pipelines can be sliced by this name.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>fit_context</code></strong> :&ensp;<code><a title="pdpipe.core.PdpApplicationContext" href="#pdpipe.core.PdpApplicationContext">PdpApplicationContext</a></code></dt>
<dd>An application context object that is only re-initialized before
<code>fit_transform</code> calls, and is locked after pipeline application. It is
injected into the PipelineStage by the encapsulating pipeline object.</dd>
<dt><strong><code>application_context</code></strong> :&ensp;<code><a title="pdpipe.core.PdpApplicationContext" href="#pdpipe.core.PdpApplicationContext">PdpApplicationContext</a></code></dt>
<dd>An application context object that is re-initialized before every
pipeline application (so, also during transform operations of fitted
pipelines), and is locked after pipeline application.It is injected
into the PipelineStage by the encapsulating pipeline object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdPipelineStage(abc.ABC):
    &#34;&#34;&#34;A stage of a pandas DataFrame-processing pipeline.

    Parameters
    ----------
    exraise : bool, default True
        If true, a pdpipe.FailedPreconditionError is raised when this
        stage is applied to a dataframe for which the precondition does
        not hold. Otherwise the stage is skipped. Additionally, if true, a
        pdpipe.FailedPostconditionError is raised if an expected post-codnition
        does not hold for an output dataframe (after pipeline application).
        Otherwise pipeline application continues uninterrupted.
    exmsg : str, default None
        The message of the exception that is raised on a failed
        precondition if exraise is set to True. A default message is used
        if None is given.
    desc : str, default None
        A short description of this stage, used as its string representation.
        A default description is used if None is given.
    prec : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the preconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed preconditions). See pdp.cond for
        more information on specialised Condition objects.
    post : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether input dataframes
        satisfy the postconditions for this pipeline stage (see the `exraise`
        parameter for the behaviour of failed postconditions). See pdp.cond for
        more information on specialised Condition objects.
    skip : callable, default None
        This can be assigned a callable that returns boolean values for input
        dataframes, which will be used to determine whether this stage should
        be skipped for input dataframes - if the callable returns True for an
        input dataframe, this stage will be skipped. See pdp.cond for more
        information on specialised Condition objects.
    name : str, default &#39;&#39;
        The name of this stage. Pipelines can be sliced by this name.

    Attributes
    ----------
    fit_context : PdpApplicationContext
        An application context object that is only re-initialized before
        `fit_transform` calls, and is locked after pipeline application. It is
        injected into the PipelineStage by the encapsulating pipeline object.
    application_context : PdpApplicationContext
        An application context object that is re-initialized before every
        pipeline application (so, also during transform operations of fitted
        pipelines), and is locked after pipeline application.It is injected
        into the PipelineStage by the encapsulating pipeline object.
    &#34;&#34;&#34;

    _DEF_EXC_MSG = &#39;Precondition failed in stage {}!&#39;
    _DEF_DESCRIPTION = &#39;A pipeline stage.&#39;
    _INIT_KWARGS = [&#39;exraise&#39;, &#39;exmsg&#39;, &#39;desc&#39;, &#39;prec&#39;, &#39;skip&#39;, &#39;name&#39;]

    def __init__(self, exraise=True, exmsg=None, desc=None, prec=None,
                 post=None, skip=None, name=&#39;&#39;):
        if not isinstance(name, str):
            raise ValueError(
                f&#34;&#39;name&#39; must be a str, not {type(name).__name__}.&#34;
            )
        if desc is None:
            desc = PdPipelineStage._DEF_DESCRIPTION
        if exmsg is None:
            exmsg = PdPipelineStage._DEF_EXC_MSG.format(desc)

        self._exraise = exraise
        self._exmsg = exmsg
        self._exmsg_post = exmsg.replace(
            &#39;precondition&#39;, &#39;postcondition&#39;).replace(
            &#39;Precondition&#39;, &#39;Postcondition&#39;)
        self._desc = desc
        self._prec_arg = prec
        self._post_arg = post
        self._skip = skip
        self._appmsg = f&#34;{name + &#39;: &#39; if name else &#39;&#39;}{desc}&#34;
        self._name = name
        self.fit_context: PdpApplicationContext = None
        self.application_context: PdpApplicationContext = None
        self.is_fitted = False

    @classmethod
    def _init_kwargs(cls):
        return cls._INIT_KWARGS

    @abc.abstractmethod
    def _prec(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage can be applied to the given dataframe.&#34;&#34;&#34;
        raise NotImplementedError

    def _compound_prec(self, df):
        if self._prec_arg:
            return self._prec_arg(df)
        return self._prec(df)

    def _post(self, df):  # pylint: disable=R0201,W0613
        &#34;&#34;&#34;Returns True if this stage resulted in an expected output frame.&#34;&#34;&#34;
        return True

    def _compound_post(self, df):
        if self._post_arg:
            return self._post_arg(df)
        return self._post(df)

    def _fit_transform(self, df, verbose):
        &#34;&#34;&#34;Fits this stage and transforms the input dataframe.&#34;&#34;&#34;
        return self._transform(df, verbose)

    def _is_fittable(self):
        if self.__class__._fit_transform == PdPipelineStage._fit_transform:
            return False
        return True

    @abc.abstractmethod
    def _transform(self, df, verbose):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.&#34;&#34;&#34;
        raise NotImplementedError(&#34;_transform method not implemented!&#34;)

    def apply(self, df, exraise=None, verbose=False):
        &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

        If the stage is not fitted fit_transform is called. Otherwise,
        transform is called.

        Parameters
        ----------
        df : pandas.DataFrame
            The dataframe to which this pipeline stage will be applied.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._skip and self._skip(df):
            return df
        if self._compound_prec(df=df):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self.is_fitted:
                res_df = self._transform(df, verbose=verbose)
            else:
                res_df = self._fit_transform(df, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return df

    __call__ = apply

    def fit_transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to transform and fit this pipeline stage by.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._compound_prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            res_df = self._fit_transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def fit(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._compound_prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            res_df = self._fit_transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return X
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def transform(self, X, y=None, exraise=None, verbose=False):
        &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

        If this stage is fittable but is not fitter, an
        UnfittedPipelineStageError is raised.

        Parameters
        ----------
        X : pandas.DataFrame
            The dataframe to be transformed.
        y : array-like, optional
            Targets for supervised learning.
        exraise : bool, default None
            Override preconditions and postconditions behaviour for this call.
            If None, the default behaviour of this stage is used, as determined
            by the exraise constructor parameter.
        verbose : bool, default False
            If True an explanation message is printed after the precondition
            is checked but before the application of the pipeline stage.
            Defaults to False.

        Returns
        -------
        pandas.DataFrame
            The resulting dataframe.
        &#34;&#34;&#34;
        if exraise is None:
            exraise = self._exraise
        if self._prec(X):
            if verbose:
                msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
                print(msg, flush=True)
            if self._is_fittable():
                if self.is_fitted:
                    res_df = self._transform(X, verbose=verbose)
                    if exraise and not self._compound_post(df=res_df):
                        raise FailedPostconditionError(self._exmsg_post)
                    return res_df
                raise UnfittedPipelineStageError(
                    &#34;transform of an unfitted pipeline stage was called!&#34;)
            res_df = self._transform(X, verbose=verbose)
            if exraise and not self._compound_post(df=res_df):
                raise FailedPostconditionError(self._exmsg_post)
            return res_df
        if exraise:
            raise FailedPreconditionError(self._exmsg)
        return X

    def __add__(self, other):
        if isinstance(other, PdPipeline):
            return PdPipeline([self, *other._stages])
        if isinstance(other, PdPipelineStage):
            return PdPipeline([self, other])
        return NotImplemented

    def __str__(self):
        return f&#34;PdPipelineStage: {self._desc}&#34;

    def __repr__(self):
        return self.__str__()

    def description(self):
        &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
        return self._desc

    def _mem_str(self):
        total = asizeof(self)
        lines = []
        for a in dir(self):
            if not a.startswith(&#39;__&#39;):
                att = getattr(self, a)
                if not callable(att):
                    size = asizeof(att)
                    if size &gt; 500000:  # pragma: no cover
                        lines.append(&#39;  - {}, {:.2f}Mb ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size / 1000000, 100 * size / total))
                    elif size &gt; 1000:  # pragma: no cover
                        lines.append(&#39;  - {}, {:.2f}Kb ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size / 1000, 100 * size / total))
                    else:
                        lines.append(&#39;  - {}, {}b ({:0&gt;5.2f}%)\n&#39;.format(
                            a, size, 100 * size / total))
        return &#39;&#39;.join(lines)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pdpipe.basic_stages.ColRename" href="basic_stages.html#pdpipe.basic_stages.ColRename">ColRename</a></li>
<li><a title="pdpipe.basic_stages.ColReorder" href="basic_stages.html#pdpipe.basic_stages.ColReorder">ColReorder</a></li>
<li><a title="pdpipe.basic_stages.ColumnDtypeEnforcer" href="basic_stages.html#pdpipe.basic_stages.ColumnDtypeEnforcer">ColumnDtypeEnforcer</a></li>
<li><a title="pdpipe.basic_stages.ConditionValidator" href="basic_stages.html#pdpipe.basic_stages.ConditionValidator">ConditionValidator</a></li>
<li><a title="pdpipe.basic_stages.DropNa" href="basic_stages.html#pdpipe.basic_stages.DropNa">DropNa</a></li>
<li><a title="pdpipe.basic_stages.FreqDrop" href="basic_stages.html#pdpipe.basic_stages.FreqDrop">FreqDrop</a></li>
<li><a title="pdpipe.basic_stages.Schematize" href="basic_stages.html#pdpipe.basic_stages.Schematize">Schematize</a></li>
<li><a title="pdpipe.basic_stages.SetIndex" href="basic_stages.html#pdpipe.basic_stages.SetIndex">SetIndex</a></li>
<li><a title="pdpipe.col_generation.ApplyToRows" href="col_generation.html#pdpipe.col_generation.ApplyToRows">ApplyToRows</a></li>
<li><a title="pdpipe.col_generation.Bin" href="col_generation.html#pdpipe.col_generation.Bin">Bin</a></li>
<li><a title="pdpipe.col_generation.ColByFrameFunc" href="col_generation.html#pdpipe.col_generation.ColByFrameFunc">ColByFrameFunc</a></li>
<li><a title="pdpipe.core.AdHocStage" href="#pdpipe.core.AdHocStage">AdHocStage</a></li>
<li><a title="pdpipe.core.ColumnsBasedPipelineStage" href="#pdpipe.core.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></li>
<li><a title="pdpipe.core.PdPipeline" href="#pdpipe.core.PdPipeline">PdPipeline</a></li>
<li><a title="pdpipe.sklearn_stages.TfidfVectorizeTokenLists" href="sklearn_stages.html#pdpipe.sklearn_stages.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></li>
<li><a title="pdpipe.wrappers.FitOnly" href="wrappers.html#pdpipe.wrappers.FitOnly">FitOnly</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.core.PdPipelineStage.AdHocStage"><code class="name flex">
<span>def <span class="ident">AdHocStage</span></span>(<span>self, transform, fit_transform=None, prec=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds an ad-hoc stage of a pandas DataFrame-processing pipeline to this pipeline stage.</p>
<p>The signature for both the <code>transform</code> and the optional <code>fit_transform</code>
callables is adaptive: The first argument is used positionally (so no
specific name is assumed or used) to supply the callable with the pandas
DataFrame object to transform. The following additional keyword arguments
are supplied if the are included in the callable's signature:
<code>verbose</code> - Passed on from pdpipe's <code>fit</code>, <code>fit_transform</code>
and <code>apply</code> methods.
<code>fit_context</code> and <code>application_context</code> - Provides fit-specific and
application-specific contexts, in the form of PdpApplicationContext
objects, usually available to pipeline stages using <code>self.fit_context</code> and
<code>self.application_context</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code></dt>
<dd>The transformation this stage applies to dataframes. If the
fit_transform parameter is also populated than this transformation is
only applied on calls to transform. See documentation for the exact
signature.</dd>
<dt><strong><code>fit_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>The transformation this stage applies to dataframes, only on
fit_transform. Optional. See documentation for the exact signature.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>callable</code>, default <code>None</code></dt>
<dd>A callable that returns a boolean value. Represent a a precondition
used to determine whether this stage can be applied to a given
dataframe. If None is given, set to a function always returning True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.AggByCols"><code class="name flex">
<span>def <span class="ident">AggByCols</span></span>(<span>self, columns, func, result_columns=None, drop=True, func_desc=None, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage applying a series-wise function to columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code></dt>
<dd>Names of columns on which to apply the given function.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each of the given columns.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the name of the source column is used;
otherwise, the name of the source column is used with a defined suffix.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The suffix to add to resulting columns in case where results_columns
is None and drop is set to False. Of not given, defaults to '_agg'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import numpy as np;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; log_ph = pdp.ApplyByCols("ph", np.log)
&gt;&gt;&gt; log_ph(df)
         ph  lbl
1  1.163151  acd
2  1.974081  alk
3  2.493205  alk
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ApplyByCols"><code class="name flex">
<span>def <span class="ident">ApplyByCols</span></span>(<span>self, columns, func, result_columns=None, drop=True, func_desc=None, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage applying an element-wise function to columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each element of the given columns.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the name of the source column is used;
otherwise, the name of the source column is used with the suffix
'_app'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. Optional.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>If provided, this string is concated to resulting column labels instead
of '_app'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp; import math;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; round_ph = pdp.ApplyByCols("ph", math.ceil)
&gt;&gt;&gt; round_ph(df)
   ph  lbl
1   4  acd
2   8  alk
3  13  alk
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ApplyToRows"><code class="name flex">
<span>def <span class="ident">ApplyToRows</span></span>(<span>self, func, colname=None, follow_column=None, func_desc=None, prec=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage generating columns by applying a function to each row to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to each row of the processed DataFrame.</dd>
<dt><strong><code>colname</code></strong> :&ensp;<code>single label</code>, default <code>None</code></dt>
<dd>The label of the new column resulting from the function application. If
None, 'new_col' is used. Ignored if a DataFrame is generated by the
function (i.e. each row generates a Series rather than a value), in
which case the laebl of each column in the resulting DataFrame is used.</dd>
<dt><strong><code>follow_column</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>Resulting columns will be inserted after this column. If None, new
columns are inserted at the end of the processed DataFrame.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>function</code>, default <code>None</code></dt>
<dd>A function taking a DataFrame, returning True if it this stage is
applicable to the given DataFrame. If None is given, a function always
returning True is used.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3, 2143], [10, 1321], [7, 1255]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ['years', 'avg_revenue'])
&gt;&gt;&gt; total_rev = lambda row: row['years'] * row['avg_revenue']
&gt;&gt;&gt; add_total_rev = pdp.ApplyToRows(total_rev, 'total_revenue')
&gt;&gt;&gt; add_total_rev(df)
   years  avg_revenue  total_revenue
1      3         2143           6429
2     10         1321          13210
3      7         1255           8785
&gt;&gt;&gt; def halfer(row):
...     new = {'year/2': row['years']/2, 'rev/2': row['avg_revenue']/2}
...     return pd.Series(new)
&gt;&gt;&gt; half_cols = pdp.ApplyToRows(halfer, follow_column='years')
&gt;&gt;&gt; half_cols(df)
   years   rev/2  year/2  avg_revenue
1      3  1071.5     1.5         2143
2     10   660.5     5.0         1321
3      7   627.5     3.5         1255
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Bin"><code class="name flex">
<span>def <span class="ident">Bin</span></span>(<span>self, bin_map, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that adds a binned version of a column or columns to this pipeline stage.</p>
<p>If drop is set to True the new columns retain the names of the source
columns; otherwise, the resulting column gain the suffix '_bin'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bin_map</code></strong> :&ensp;<code>dict</code></dt>
<dd>Maps column labels to bin arrays. The bin array is interpreted as
containing start points of consecutive bins, except for the final
point, assumed to be the end point of the last bin. Additionally, a
bin array implicitly projects a left-most bin containing all elements
smaller than the left-most end point and a right-most bin containing
all elements larger that the right-most end point. For example, the
list [0, 5, 8] is interpreted as the bins (-âˆž, 0), [0-5), [5-8) and
[8, âˆž).</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being binned.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[-3],[4],[5], [9]], [1,2,3, 4], ['speed'])
&gt;&gt;&gt; pdp.Bin({'speed': [5]}, drop=False).apply(df)
   speed speed_bin
1     -3        &lt;5
2      4        &lt;5
3      5        5â‰¤
4      9        5â‰¤
&gt;&gt;&gt; pdp.Bin({'speed': [0,5,8]}, drop=False).apply(df)
   speed speed_bin
1     -3        &lt;0
2      4       0-5
3      5       5-8
4      9        8â‰¤
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColByFrameFunc"><code class="name flex">
<span>def <span class="ident">ColByFrameFunc</span></span>(<span>self, column, func, follow_column=None, before_column=None, func_desc=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage adding a column by applying a dataframw-wide function to this pipeline stage.</p>
<p>Note that assigning <code>column</code> with the label of an existing column and
providing the same label to the <code>before_column</code> parameter will result in
replacing the original column at the same location.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The label of the resulting column. If its the label of an existing
column it will replace that column.</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The function to be applied to the input dataframe. The function should
return a pandas.Series object.</dd>
<dt><strong><code>follow_column</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>Resulting columns will be inserted after this column. If both this
parameter and <code>before_column</code> are None, new columns are inserted at the
end of the processed DataFrame.</dd>
<dt><strong><code>before_column</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>Resulting columns will be inserted before this column. If both this
parameter and <code>follow_colum</code> are None, new columns are inserted at the
end of the processed DataFrame. If both are provided, <code>before_column</code>
takes precedence.</dd>
<dt><strong><code>func_desc</code></strong> :&ensp;<code>str</code>, default <code>None</code></dt>
<dd>A function description of the given function; e.g. 'normalizing revenue
by company size'. A default description is used if None is given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3, 3], [2, 4], [1, 5]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["A","B"])
&gt;&gt;&gt; func = lambda df: df['A'] == df['B']
&gt;&gt;&gt; add_equal = pdp.ColByFrameFunc("A==B", func)
&gt;&gt;&gt; add_equal(df)
   A  B   A==B
1  3  3   True
2  2  4  False
3  1  5  False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColDrop"><code class="name flex">
<span>def <span class="ident">ColDrop</span></span>(<span>self, columns:Â Union[object,Â List[object],Â <built-inÂ functionÂ callable>], errors:Â Optional[str]Â =Â None, **kwargs:Â object)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drops columns by name to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to drop. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>{â€˜ignoreâ€™, â€˜raiseâ€™}</code>, default <code>â€˜raiseâ€™</code></dt>
<dd>If â€˜ignoreâ€™, suppress error and existing labels are dropped.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; pdp.ColDrop('num').apply(df)
  char
1    a
2    b
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColRename"><code class="name flex">
<span>def <span class="ident">ColRename</span></span>(<span>self, rename_mapper, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that renames a column or columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rename_mapper</code></strong> :&ensp;<code>dict-like</code> or <code>function</code></dt>
<dd>Maps old column names to new ones.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; pdp.ColRename({'num': 'len', 'char': 'initial'}).apply(df)
   len initial
1    8       a
2    5       b
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColReorder"><code class="name flex">
<span>def <span class="ident">ColReorder</span></span>(<span>self, positions, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that reorders columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>dict</code></dt>
<dd>A mapping of column names to their desired positions after reordering.
Columns not included in the mapping will maintain their relative
positions over the non-mapped colums.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,4,3,7]], columns=['a', 'b', 'c', 'd'])
&gt;&gt;&gt; pdp.ColReorder({'b': 0, 'c': 3}).apply(df)
   b  a  d  c
0  4  8  7  3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer"><code class="name flex">
<span>def <span class="ident">ColumnDtypeEnforcer</span></span>(<span>self, column_to_dtype:Â Dict[str,Â object], errors:Â Optional[str]Â =Â 'raise', **kwargs:Â object)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage enforcing column dtypes to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column_to_dtype</code></strong> :&ensp;<code>dict</code> of <code>column name -&gt; data type</code></dt>
<dd>Use {col: dtype, â€¦}, where col is a column label and dtype is a
numpy.dtype or Python type to cast one or more of the DataFrameâ€™s
columns to column-specific types.</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>{â€˜raiseâ€™, â€˜ignoreâ€™}</code>, default <code>â€˜raiseâ€™</code></dt>
<dd>Control raising of exceptions on invalid data for provided dtype.
- raise : allow exceptions to be raised
- ignore : suppress exceptions. On error return original object.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'initial'])
&gt;&gt;&gt; pdp.ColumnDtypeEnforcer({'num': float}).apply(df)
   num initial
1  8.0       a
2  5.0       b
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColumnTransformer"><code class="name flex">
<span>def <span class="ident">ColumnTransformer</span></span>(<span>self, columns, result_columns=None, drop=True, suffix=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that applies transformation to dataframe columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq. If None is provided all
input columns are transformed.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>single label</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Labels for the new columns resulting from the transformations. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, then the label of the source column is
used; otherwise, the provided 'suffix' is concatenated to the label of
the source column.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>'_transformed'</code></dt>
<dd>The suffix transformed columns gain if no new column labels are given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1], [3], [2]], ['UK', 'USSR', 'US'], ['Medal'])
&gt;&gt;&gt; value_map = {1: 'Gold', 2: 'Silver', 3: 'Bronze'}
&gt;&gt;&gt; pdp.MapColVals('Medal', value_map).apply(df)
       Medal
UK      Gold
USSR  Bronze
US    Silver
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage"><code class="name flex">
<span>def <span class="ident">ColumnsBasedPipelineStage</span></span>(<span>self, columns, exclude_columns=None, desc_temp=None, none_columns='error', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that operates on a subset of dataframe columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code></dt>
<dd>The label, or an iterable of labels, of columns to use. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
<dt><strong><code>desc_temp</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If given, assumed to be a format string, and every appearance of {} in
it is replaced with an appropriate string representation of the columns
parameter, and is used as the pipeline description. Ignored if <code>desc</code>
is provided.</dd>
<dt><strong><code>none_columns</code></strong> :&ensp;<code>iterable, callable</code> or <code>str</code>, default <code>'error'</code></dt>
<dd>Determines how None values supplied to the 'columns' parameter should
be handled. If set to 'error', the default, a ValueError is raised if
None is encountered. If set to 'all', it is interpreted to mean all
columns of input dataframes should be operated on. If an iterable is
provided it is interpreted as the default list of columns to operate on
when <code>columns=None</code>. If a callable is provided, it is interpreted as
the default column qualifier that determines input columns when
<code>columns=None</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additionally supports all constructor parameters of PdPipelineStage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ConditionValidator"><code class="name flex">
<span>def <span class="ident">ConditionValidator</span></span>(<span>self, conditions:Â Union[Callable,Â List[Callable]], reducer:Â Optional[Callable]Â =Â &lt;built-in function all&gt;, errors:Â Optional[str]Â =Â 'raise', **kwargs:Â object)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that validates boolean conditions on dataframes to this pipeline stage.</p>
<p>The stage does not change the input dataframe in any way.</p>
<p>The constructor expects either a single callable or a list-like of callable
objects, and checks that all these callable return True - meaning all
defined conditions hold - for input dataframes.</p>
<p>Naturally, pdpipe Condition objects from the pdpipe.cond module can be
used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conditions</code></strong> :&ensp;<code>callable</code> or <code>list-like</code> of <code>callable</code></dt>
<dd>The conditions to check for input dataframes. Naturally, pdpipe
Condition objects from the pdpipe.cond module can be used.</dd>
<dt><strong><code>reducer</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>The callable that reduces the list of boolean result to a single
result. By default the built-in <code>all</code> function is used, so all
conditions must hold for this pipeline stage to validate an input
dataframe. The built-in <code>any</code> function may be used to validate at least
one condition holds, and of course custom reducing functions can be
used.</dd>
<dt><strong><code>errors</code></strong> :&ensp;<code>str</code>, default <code>'raise'</code></dt>
<dd>If set to 'raise', the default, then if the result boolean result is
False a FailedConditionError is raised on stage application. If set to
'ignore', then conditions are checked, the results are printed if the
application was called with <code>verbose=True</code>, and pipeline application
continues. Any other value is interpreted as 'raise'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,None],[1,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.ConditionValidator(pdp.cond.HasNoMissingValues())(df)
Traceback (most recent call last):
   ...
pdpipe.exceptions.FailedConditionError: ConditionValidator stage failed; some conditions did not hold for the input dataframe!
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropDuplicates"><code class="name flex">
<span>def <span class="ident">DropDuplicates</span></span>(<span>self, columns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Drop duplicates in the given columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>column label</code> or <code>sequence</code> of <code>labels</code>, optional</dt>
<dd>The labels of the columns to consider for duplication drop. If not
populated, duplicates are dropped from all columns.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8, 1],[8, 2], [9, 2]], [1,2,3], ['a', 'b'])
&gt;&gt;&gt; pdp.DropDuplicates('a').apply(df)
   a  b
1  8  1
3  9  2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropNa"><code class="name flex">
<span>def <span class="ident">DropNa</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drops null values to this pipeline stage.</p>
<p>Supports all parameter supported by pandas.dropna function.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,None],[1,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.DropNa().apply(df)
   a     b
1  1   4.0
3  1  11.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropRareTokens"><code class="name flex">
<span>def <span class="ident">DropRareTokens</span></span>(<span>self, columns, threshold, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drop rare tokens from token lists to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>The rarity threshold to use. Only tokens appearing more than this
number of times in a column will remain in token lists in that column.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being transformed,
and the resulting columns retain the names of the source columns.
Otherwise, the new columns gain the suffix '_norare'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[7, ['a', 'a', 'b']], [3, ['b', 'c', 'd']]]
&gt;&gt;&gt; df = pd.DataFrame(data, columns=['num', 'chars'])
&gt;&gt;&gt; rare_dropper = pdp.DropRareTokens('chars', 1)
&gt;&gt;&gt; rare_dropper(df)
   num      chars
0    7  [a, a, b]
1    3        [b]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropTokensByLength"><code class="name flex">
<span>def <span class="ident">DropTokensByLength</span></span>(<span>self, columns, min_len, max_len=None, result_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage removing tokens by length in string-token list columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code></dt>
<dd>Names of token list columns on which to apply token filtering.</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code></dt>
<dd>The minimum length of tokens to keep. Tokens of shorter length are
removed from all token lists.</dd>
<dt><strong><code>max_len</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>The maximum length of tokens to keep. If provided, tokens of longer
length are removed from all token lists.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation.
Must be of the same length as columns. If None, behavior depends on
the drop parameter: If drop is True, the name of the source column
is used; otherwise, the name of the source column is used with the
suffix '_filtered'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, ["a", "bad", "nice"]], [5, ["good", "university"]]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; filter_tokens = pdp.DropTokensByLength('text', 3, 5)
&gt;&gt;&gt; filter_tokens(df)
   age         text
1    4  [bad, nice]
2    5       [good]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.DropTokensByList"><code class="name flex">
<span>def <span class="ident">DropTokensByList</span></span>(<span>self, columns, bad_tokens, result_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage removing specific tokens in string-token list columns to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code></dt>
<dd>Names of token list columns on which to apply token filtering.</dd>
<dt><strong><code>bad_tokens</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The list of string tokens to remove from all token lists.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>The names of the new columns resulting from the mapping operation.
Must be of the same length as columns. If None, behavior depends on
the drop parameter: If drop is True, the name of the source column
is used; otherwise, the name of the source column is used with the
suffix '_filtered'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, ["a", "bad", "cat"]], [5, ["bad", "not", "good"]]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; filter_tokens = pdp.DropTokensByList('text', ['bad'])
&gt;&gt;&gt; filter_tokens(df)
   age         text
1    4     [a, cat]
2    5  [not, good]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Encode"><code class="name flex">
<span>def <span class="ident">Encode</span></span>(<span>self, columns=None, exclude_columns=None, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that encodes categorical columns to integer values to this pipeline stage.</p>
<p>The encoder for each column is saved in the attribute 'encoders', which
is a dict mapping each encoded column name to the
sklearn.preprocessing.LabelEncoder object used to encode it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be encoded. If columns is None then
all the columns with object or category dtype will be converted, except
those given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being encoded,
and the resulting encoded columns retain the names of the source
columns. Otherwise, encoded columns gain the suffix '_enc'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; encode_stage = pdp.Encode("lbl")
&gt;&gt;&gt; encode_stage(df)
     ph  lbl
1   3.2    0
2   7.2    1
3  12.1    1
&gt;&gt;&gt; encode_stage.encoders["lbl"].inverse_transform([0,1,1])
array(['acd', 'alk', 'alk'], dtype=object)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.FitOnly"><code class="name flex">
<span>def <span class="ident">FitOnly</span></span>(<span>self, stage, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a wrapper that applies a stage to input data only when fitting to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></code></dt>
<dd>The pipeline stage to operate on input data only when fitting.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; stage = pdp.FitOnly(pdp.ColDrop('num'))
&gt;&gt;&gt; stage(df)
  char
1    a
2    b
&gt;&gt;&gt; df2 = pd.DataFrame([[8,'a'],[5,'b']], [1,2], ['num', 'char'])
&gt;&gt;&gt; stage(df2)
   num char
1    8    a
2    5    b
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.FreqDrop"><code class="name flex">
<span>def <span class="ident">FreqDrop</span></span>(<span>self, threshold, column, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drops rows by value frequency to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>The minimum frequency required for a value to be kept.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the colum to check for the given value frequency.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[1,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.FreqDrop(2, 'a').apply(df)
   a   b
1  1   4
3  1  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Log"><code class="name flex">
<span>def <span class="ident">Log</span></span>(<span>self, columns=None, exclude_columns=None, drop=False, non_neg=False, const_shift=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that log-transforms numeric data to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Column names in the DataFrame to be encoded. If columns is None then
all the columns with a numeric dtype will be transformed, except those
given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq. Optional.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the source columns are dropped after being encoded,
and the resulting encoded columns retain the names of the source
columns. Otherwise, encoded columns gain the suffix '_log'.</dd>
<dt><strong><code>non_neg</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, each transformed column is first shifted by the smallest
negative value it includes (non-negative columns are thus not shifted).</dd>
<dt><strong><code>const_shift</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If given, each transformed column is first shifted by this constant. If
non_neg is True then that transformation is applied first, and only
then is the column shifted by this constant.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, "acd"], [7.2, "alk"], [12.1, "alk"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","lbl"])
&gt;&gt;&gt; log_stage = pdp.Log("ph", drop=True)
&gt;&gt;&gt; log_stage(df)
         ph  lbl
1  1.163151  acd
2  1.974081  alk
3  2.493205  alk
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.MapColVals"><code class="name flex">
<span>def <span class="ident">MapColVals</span></span>(<span>self, columns:Â Union[object,Â List[object],Â <built-inÂ functionÂ callable>], value_map:Â Union[dict,Â pandas.core.series.Series,Â Callable,Â str,Â Tuple[str,Â dict]], result_columns:Â Union[object,Â List[object],Â None]Â =Â None, drop:Â Optional[bool]Â =Â True, suffix:Â Optional[str]Â =Â None, **kwargs:Â Dict[str,Â object])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that replaces the values of a column by a map to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code></dt>
<dd>Column labels in the DataFrame to be mapped. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq. If None is provided all
input columns are mapped.</dd>
<dt><strong><code>value_map</code></strong> :&ensp;<code>dict, pandas.Series, callable, str</code> or <code>tuple</code></dt>
<dd>The value-to-value map to use, mapping existing values to new one. If a
dictionary is provided, its mapping is used. Values not in the
dictionary as keys will be converted to NaN. If a Series is given,
values are mapped by its index to its values. If a callable is given,
it is applied element-wise to given columns. If a string is given, it
is interpreted as the name of an attribute or a property of the series
values to use as target values. If a tuple is provided, its first
element is expected to be a string, interpreted as a name of a method
of the series values to call, and its second element is expected to be
a dict - possibly empty - mapping additional keyword arguments names
to their values.</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>single label</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Labels for the new columns resulting from the mapping operation. Must
be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, then the label of the source column is
used; otherwise, the label of the source column is used with the suffix
'_map'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being mapped.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code>, default <code>'_map'</code></dt>
<dd>The suffix mapped columns gain if no new column labels are given.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1], [3], [2]], ['UK', 'USSR', 'US'], ['Medal'])
&gt;&gt;&gt; value_map = {1: 'Gold', 2: 'Silver', 3: 'Bronze'}
&gt;&gt;&gt; pdp.MapColVals('Medal', value_map).apply(df)
       Medal
UK      Gold
USSR  Bronze
US    Silver
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.OneHotEncode"><code class="name flex">
<span>def <span class="ident">OneHotEncode</span></span>(<span>self, columns=None, dummy_na=False, exclude_columns=None, drop_first=True, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that one-hot-encodes categorical columns to this pipeline stage.</p>
<p>By default only k-1 dummies are created fo k categorical levels, as to
avoid perfect multicollinearity between the dummy features (also called
the dummy variabletrap). This is done since features are usually one-hot
encoded for use with linear models, which require this behaviour.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be encoded. If columns is None then
all the columns with object or category dtype will be converted, except
those given in the exclude_columns parameter. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>dummy_na</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Add a column to indicate NaNs, if False NaNs are ignored.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, default <code>None</code></dt>
<dd>Label or labels of columns to be excluded from encoding. If None then
no column is excluded. Alternatively, this parameter can be assigned a
callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq. Optional.</dd>
<dt><strong><code>drop_first</code></strong> :&ensp;<code>bool</code> or <code>single label</code>, default <code>True</code></dt>
<dd>Whether to get k-1 dummies out of k categorical levels by removing the
first level. If a non bool argument matching one of the categories is
provided, the dummy column corresponding to this value is dropped
instead of the first level; if it matches no category the first
category will still be dropped.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being encoded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([['USA'], ['UK'], ['Greece']], [1,2,3], ['Born'])
&gt;&gt;&gt; pdp.OneHotEncode().apply(df)
   Born_UK  Born_USA
1        0         1
2        1         0
3        0         0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.PdPipeline"><code class="name flex">
<span>def <span class="ident">PdPipeline</span></span>(<span>self, stages, transformer_getter=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline for processing pandas DataFrame objects to this pipeline stage.</p>
<p>transformer_getter is usefull to avoid applying pipeline stages that are
aimed to filter out items in a big dataset to create a training set for a
machine learning model, for example, but should not be applied on future
individual items to be transformed by the fitted pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stages</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of PdPipelineStage objects making up this pipeline.</dd>
<dt><strong><code>transform_getter</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A callable that can be applied to the fitted pipeline to produce a
sub-pipeline of it which should be used to transform dataframes after
the pipeline has been fitted. If not given, the fitted pipeline is used
entirely.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RegexReplace"><code class="name flex">
<span>def <span class="ident">RegexReplace</span></span>(<span>self, columns:Â Union[object,Â List[object],Â <built-inÂ functionÂ callable>], pattern:Â str, replace:Â str, flags:Â Optional[int]Â =Â 0, result_columns:Â Union[object,Â List[object],Â None]Â =Â None, drop:Â Optional[bool]Â =Â True, func_desc:Â Optional[str]Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage replacing regex occurences in a text column to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame which regex replacement be applied to.
Alternatively, this parameter can be assigned a callable returning an
iterable of labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The regex whose occurences will be replaced.</dd>
<dt><strong><code>replace</code></strong> :&ensp;<code>str</code></dt>
<dd>The replacement string to use. This is equivalent to repl in re.sub.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>result_columns</code></strong> :&ensp;<code>label</code> or <code>list-like</code> of <code>labels</code>, default <code>None</code></dt>
<dd>The labels of the new columns resulting from the mapping operation.
Must be of the same length as columns. If None, behavior depends on the
drop parameter: If drop is True, the label of the source column is
used; otherwise, the label of the source column is caster to a string
and concatenated with the suffix '_reg'.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, source columns are dropped after being transformed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[4, "more than 12"], [5, "with 5 more"]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2], ["age","text"])
&gt;&gt;&gt; clean_num = pdp.RegexReplace('text', r'\b[0-9]+\b', "NUM")
&gt;&gt;&gt; clean_num(df)
   age           text
1    4  more than NUM
2    5  with NUM more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RemoveStopwords"><code class="name flex">
<span>def <span class="ident">RemoveStopwords</span></span>(<span>self, language, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that removes stopwords from a tokenized list to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>langugae</code></strong> :&ensp;<code>str</code> or <code>array-like</code></dt>
<dd>If a string is given, interpreted as the language of the stopwords, and
should then be one of the languages supported by the NLTK Stopwords
Corpus. If a list is given, it is assumed to be the list of stopwords
to remove.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after stopword removal,
and the resulting columns retain the names of the source columns.
Otherwise, resulting columns gain the suffix '_nostop'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt; data = [[3.2, ['kick', 'the', 'baby']]]
&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt; remove_stopwords = pdp.RemoveStopwords('english', 'content')
&gt;&gt; remove_stopwords(df)
   freq       content
1   3.2  [kick, baby]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.RowDrop"><code class="name flex">
<span>def <span class="ident">RowDrop</span></span>(<span>self, conditions, reduce=None, columns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drop rows by callable conditions to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conditions</code></strong> :&ensp;<code>list-like</code> or <code>dict</code></dt>
<dd>The list of conditions that make a row eligible to be dropped. Each
condition must be a callable that take a cell value and return a bool
value. If a list of callables is given, the conditions are checked for
each column value of each row. If a dict mapping column labels to
callables is given, then each condition is only checked for the column
values of the designated column.</dd>
<dt><strong><code>reduce</code></strong> :&ensp;<code>'any', 'all'</code> or <code>'xor'</code>, default <code>'any'</code></dt>
<dd>Determines how row conditions are reduced. If set to 'all', a row must
satisfy all given conditions to be dropped. If set to 'any', rows
satisfying at least one of the conditions are dropped. If set to 'xor',
rows satisfying exactly one of the conditions will be dropped. Set to
'any' by default.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>str</code> or <code>iterable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq. If given,
input conditions will be applied to the sub-dataframe made up of
these columns to determine which rows to drop. Ignored if <code>conditions</code>
is provided with a dict object. If <code>conditions</code> is a list and this
parameter is not provided, all columns are checked (unless
<code>exclude_columns</code> is additionally provided)</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[5,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.RowDrop([lambda x: x &lt; 2]).apply(df)
   a   b
2  4   5
3  5  11
&gt;&gt;&gt; pdp.RowDrop({'a': lambda x: x == 4}).apply(df)
   a   b
1  1   4
3  5  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Scale"><code class="name flex">
<span>def <span class="ident">Scale</span></span>(<span>self, scaler, columns=None, exclude_columns=None, joint=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that scales data to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scaler</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of scaler to use to scale the data. One of 'StandardScaler',
'MinMaxScaler', 'MaxAbsScaler', 'RobustScaler', 'QuantileTransformer'
and 'Normalizer'.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>Column labels in the DataFrame to be scale. If columns is None then
all columns of numeric dtype will be scaled, except those given in the
exclude_columns parameter. Alternatively, this parameter can be
assigned a callable returning an iterable of labels from an input
pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>str</code> or <code>list-like</code>, optional</dt>
<dd>Label or labels of columns to be excluded from encoding. Alternatively,
this parameter can be assigned a callable returning an iterable of
labels from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>joint</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, all scaled columns will be scaled as a single value
set (meaning, only the single largest value among all input columns
will be scaled to 1, and not the largest one for each column).</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>extra keyword arguments</code></dt>
<dd>All valid extra keyword arguments are forwarded to the scaler
constructor on scaler creation (e.g. 'n_quantiles' for
QuantileTransformer). PdPipelineStage valid keyword arguments are used
to override Scale class defaults.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, 0.3], [7.2, 0.35], [12.1, 0.29]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1,2,3], ["ph","gt"])
&gt;&gt;&gt; scale_stage = pdp.Scale("StandardScaler")
&gt;&gt;&gt; scale_stage(df)
         ph        gt
1 -1.181449 -0.508001
2 -0.082427  1.397001
3  1.263876 -0.889001
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.Schematize"><code class="name flex">
<span>def <span class="ident">Schematize</span></span>(<span>self, columns, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Enforces a column schema on input dataframes to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>sequence</code> of <code>labels</code></dt>
<dd>The dataframe schema to enfore on input dataframes.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[2, 4, 8],[3, 6, 9]], [1, 2], ['a', 'b', 'c'])
&gt;&gt;&gt; pdp.Schematize(['a', 'c']).apply(df)
   a  c
1  2  8
2  3  9
&gt;&gt;&gt; pdp.Schematize(['c', 'b']).apply(df)
   c  b
1  8  4
2  9  6
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.SetIndex"><code class="name flex">
<span>def <span class="ident">SetIndex</span></span>(<span>self, keys, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that set existing columns as index to this pipeline stage.</p>
<p>Supports all parameter supported by pandas.set_index function except for
<code>inplace</code>.</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt; df = pd.DataFrame([[1,4],[3, 11]], [1,2], ['a','b'])
&gt;&gt; pdp.SetIndex('a').apply(df)
    b
a
1   4
3  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.SnowballStem"><code class="name flex">
<span>def <span class="ident">SnowballStem</span></span>(<span>self, stemmer_name, columns, drop=True, min_len=None, max_len=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that stems tokens in a list using the Snowball stemmer to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stemmer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Snowball stemmer to use. Should be one of the Snowball
stemmers implemented by nltk. E.g. 'EnglishStemmer'.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after stemming, and the
resulting columns retain the names of the source columns. Otherwise,
resulting columns gain the suffix '_stem'.</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If provided, tokens shorter than this length are not stemmed.</dd>
<dt><strong><code>max_len</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If provided, tokens longer than this length are not stemmed.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, ['kicking', 'boats']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt;&gt; remove_stopwords = pdp.SnowballStem('EnglishStemmer', 'content')
&gt;&gt;&gt; remove_stopwords(df)
   freq       content
1   3.2  [kick, boat]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists"><code class="name flex">
<span>def <span class="ident">TfidfVectorizeTokenLists</span></span>(<span>self, column, drop=True, hierarchical_labels=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage TFIDF-vectorizing a token-list column to count columns to this pipeline stage.</p>
<p>Every cell in the input columns is assumed to be a list of strings, each
representing a single token. The resulting TF-IDF vector is exploded into
individual columns, each with the label 'lbl_i' where lbl is the original
column label and i is the index of column in the count vector.</p>
<p>The resulting columns are concatenated to the end of the dataframe.</p>
<p>All valid sklearn.TfidfVectorizer keyword arguemnts can be provided as
keyword arguments to the constructor, except 'input' and 'analyzer', which
will be ignored. As usual, all valid PdPipelineStage constructor parameters
can also be provided as keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>The label of the token-list column to TfIdf-vectorize.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source column is dropped after being transformed.</dd>
<dt><strong><code>hierarchical_labels</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the labels of resulting columns are of the form 'P_F'
where P is the label of the original token-list column and F is the
feature name (i.e. the string token it corresponds to). Otherwise, it
is simply the feature name itself. If you plan to have two different
TfidfVectorizeTokenLists pipeline stages vectorizing two different
token-list columns, you should set this to true, so tf-idf features
originating in different text columns do not overwrite one another.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[2, ['hovercraft', 'eels']], [5, ['eels', 'urethra']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1, 2], ['Age', 'tokens'])
&gt;&gt;&gt; tfvectorizer = pdp.TfidfVectorizeTokenLists('tokens')
&gt;&gt;&gt; tfvectorizer(df)
   Age      eels  hovercraft   urethra
1    2  0.579739    0.814802  0.000000
2    5  0.579739    0.000000  0.814802
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.TokenizeText"><code class="name flex">
<span>def <span class="ident">TokenizeText</span></span>(<span>self, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that tokenize a text column into token lists to this pipeline stage.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being tokenized,
and the resulting tokenized columns retain the names of the source
columns. Otherwise, tokenized columns gain the suffix '_tok'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame(
...     [[3.2, "Kick the baby!"]], [1], ['freq', 'content'])
&gt;&gt;&gt; tokenize_stage = pdp.TokenizeText('content')
&gt;&gt;&gt; tokenize_stage(df)
   freq               content
1   3.2  [Kick, the, baby, !]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.UntokenizeText"><code class="name flex">
<span>def <span class="ident">UntokenizeText</span></span>(<span>self, columns, drop=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that joins token lists to whitespace-seperated strings to this pipeline stage.</p>
<p>Target columns must be series of token lists; i.e. every cell in the series
is an iterable of string tokens.</p>
<p>Note: The nltk package must be installed for this pipeline stage to work.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> of <code>callable</code></dt>
<dd>Column labels in the DataFrame to be transformed. Alternatively, this
parameter can be assigned a callable returning an iterable of labels
from an input pandas.DataFrame. See pdpipe.cq.</dd>
<dt><strong><code>drop</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the source columns are dropped after being untokenized,
and the resulting columns retain the names of the source columns.
Otherwise, untokenized columns gain the suffix '_untok'.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; data = [[3.2, ['Shake', 'and', 'bake!']]]
&gt;&gt;&gt; df = pd.DataFrame(data, [1], ['freq', 'content'])
&gt;&gt;&gt; untokenize_stage = pdp.UntokenizeText('content')
&gt;&gt;&gt; untokenize_stage(df)
   freq          content
1   3.2  Shake and bake!
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ValDrop"><code class="name flex">
<span>def <span class="ident">ValDrop</span></span>(<span>self, values:Â List[object], columns:Â Union[object,Â List[object],Â <built-inÂ functionÂ callable>]Â =Â None, **kwargs:Â object)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that drops rows by value to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>list-like</code></dt>
<dd>A list of the values to drop.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>The label, or an iterable of labels, of columns to check for the given
values. Alternatively, this parameter can be assigned a callable
returning an iterable of labels from an input pandas.DataFrame. See
pdpipe.cq. If set to None, all columns are checked.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[18,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.ValDrop([4], 'a').apply(df)
    a   b
1   1   4
3  18  11
&gt;&gt;&gt; pdp.ValDrop([4]).apply(df)
    a   b
3  18  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.ValKeep"><code class="name flex">
<span>def <span class="ident">ValKeep</span></span>(<span>self, values, columns=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and adds a pipeline stage that keeps rows by value to this pipeline stage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>list-like</code></dt>
<dd>A list of the values to keep.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>single label, list-like</code> or <code>callable</code>, default <code>None</code></dt>
<dd>The label, or an iterable of labels, of columns to check for the given
values. Alternatively, this parameter can be assigned a callable
returning an iterable of labels from an input pandas.DataFrame. See
pdpipe.cq. If set to None, all columns are checked.</dd>
<dt><strong><code>exclude_columns</code></strong> :&ensp;<code>object, iterable</code> or <code>callable</code>, optional</dt>
<dd>The label, or an iterable of labels, of columns to exclude, given the
<code>columns</code> parameter. Alternatively, this parameter can be assigned a
callable returning a labels iterable from an input pandas.DataFrame.
See pdpipe.cq. Optional. By default no columns are excluded.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; import pandas as pd; import pdpipe as pdp;
&gt;&gt;&gt; df = pd.DataFrame([[1,4],[4,5],[5,11]], [1,2,3], ['a','b'])
&gt;&gt;&gt; pdp.ValKeep([4, 5], 'a').apply(df)
   a   b
2  4   5
3  5  11
&gt;&gt;&gt; pdp.ValKeep([4, 5]).apply(df)
   a  b
2  4  5
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _append_stage_func(self, *args, **kwds):
    # self is always a PdPipelineStage
    return self + class_obj(*args, **kwds)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies this pipeline stage to the given dataframe.</p>
<p>If the stage is not fitted fit_transform is called. Otherwise,
transform is called.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to which this pipeline stage will be applied.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Override preconditions and postconditions behaviour for this call.
If None, the default behaviour of this stage is used, as determined
by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, df, exraise=None, verbose=False):
    &#34;&#34;&#34;Applies this pipeline stage to the given dataframe.

    If the stage is not fitted fit_transform is called. Otherwise,
    transform is called.

    Parameters
    ----------
    df : pandas.DataFrame
        The dataframe to which this pipeline stage will be applied.
    exraise : bool, default None
        Override preconditions and postconditions behaviour for this call.
        If None, the default behaviour of this stage is used, as determined
        by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._skip and self._skip(df):
        return df
    if self._compound_prec(df=df):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        if self.is_fitted:
            res_df = self._transform(df, verbose=verbose)
        else:
            res_df = self._fit_transform(df, verbose=verbose)
        if exraise and not self._compound_post(df=res_df):
            raise FailedPostconditionError(self._exmsg_post)
        return res_df
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return df</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.description"><code class="name flex">
<span>def <span class="ident">description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the description of this pipeline stage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def description(self):
    &#34;&#34;&#34;Returns the description of this pipeline stage&#34;&#34;&#34;
    return self._desc</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this stage without transforming the given dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to be transformed.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Override preconditions and postconditions behaviour for this call.
If None, the default behaviour of this stage is used, as determined
by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Fits this stage without transforming the given dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to be transformed.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Override preconditions and postconditions behaviour for this call.
        If None, the default behaviour of this stage is used, as determined
        by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._compound_prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        res_df = self._fit_transform(X, verbose=verbose)
        if exraise and not self._compound_post(df=res_df):
            raise FailedPostconditionError(self._exmsg_post)
        return X
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.fit_transform"><code class="name flex">
<span>def <span class="ident">fit_transform</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits this stage and transforms the given dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to transform and fit this pipeline stage by.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Override preconditions and postconditions behaviour for this call.
If None, the default behaviour of this stage is used, as determined
by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_transform(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Fits this stage and transforms the given dataframe.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to transform and fit this pipeline stage by.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Override preconditions and postconditions behaviour for this call.
        If None, the default behaviour of this stage is used, as determined
        by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._compound_prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        res_df = self._fit_transform(X, verbose=verbose)
        if exraise and not self._compound_post(df=res_df):
            raise FailedPostconditionError(self._exmsg_post)
        return res_df
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdPipelineStage.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X, y=None, exraise=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the given dataframe without fitting this stage.</p>
<p>If this stage is fittable but is not fitter, an
UnfittedPipelineStageError is raised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The dataframe to be transformed.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code>, optional</dt>
<dd>Targets for supervised learning.</dd>
<dt><strong><code>exraise</code></strong> :&ensp;<code>bool</code>, default <code>None</code></dt>
<dd>Override preconditions and postconditions behaviour for this call.
If None, the default behaviour of this stage is used, as determined
by the exraise constructor parameter.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True an explanation message is printed after the precondition
is checked but before the application of the pipeline stage.
Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>The resulting dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X, y=None, exraise=None, verbose=False):
    &#34;&#34;&#34;Transforms the given dataframe without fitting this stage.

    If this stage is fittable but is not fitter, an
    UnfittedPipelineStageError is raised.

    Parameters
    ----------
    X : pandas.DataFrame
        The dataframe to be transformed.
    y : array-like, optional
        Targets for supervised learning.
    exraise : bool, default None
        Override preconditions and postconditions behaviour for this call.
        If None, the default behaviour of this stage is used, as determined
        by the exraise constructor parameter.
    verbose : bool, default False
        If True an explanation message is printed after the precondition
        is checked but before the application of the pipeline stage.
        Defaults to False.

    Returns
    -------
    pandas.DataFrame
        The resulting dataframe.
    &#34;&#34;&#34;
    if exraise is None:
        exraise = self._exraise
    if self._prec(X):
        if verbose:
            msg = &#39;- &#39; + &#39;\n  &#39;.join(textwrap.wrap(self._appmsg))
            print(msg, flush=True)
        if self._is_fittable():
            if self.is_fitted:
                res_df = self._transform(X, verbose=verbose)
                if exraise and not self._compound_post(df=res_df):
                    raise FailedPostconditionError(self._exmsg_post)
                return res_df
            raise UnfittedPipelineStageError(
                &#34;transform of an unfitted pipeline stage was called!&#34;)
        res_df = self._transform(X, verbose=verbose)
        if exraise and not self._compound_post(df=res_df):
            raise FailedPostconditionError(self._exmsg_post)
        return res_df
    if exraise:
        raise FailedPreconditionError(self._exmsg)
    return X</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pdpipe.core.PdpApplicationContext"><code class="flex name class">
<span>class <span class="ident">PdpApplicationContext</span></span>
<span>(</span><span>fit_context=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An object encapsulating the application context of a pipeline.</p>
<p>It is meant to communicate data, information and variables between
different stages of a pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fit_context</code></strong> :&ensp;<code><a title="pdpipe.core.PdpApplicationContext" href="#pdpipe.core.PdpApplicationContext">PdpApplicationContext</a></code>, optional</dt>
<dd>Another application context object, representing the application
context of a previous fit of the pipelline this application context
is initialized for. Optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdpApplicationContext(dict):
    &#34;&#34;&#34;An object encapsulating the application context of a pipeline.

    It is meant to communicate data, information and variables between
    different stages of a pipeline.

    Parameters
    ----------
    fit_context : PdpApplicationContext, optional
        Another application context object, representing the application
        context of a previous fit of the pipelline this application context
        is initialized for. Optional.
    &#34;&#34;&#34;

    def __init__(self, fit_context=None):
        self.__locked__ = False
        self._fit_context__ = fit_context

    def __setitem__(self, key, value):
        if not self.__locked__:
            super().__setitem__(key, value)

    def __delitem__(self, key):
        if not self.__locked__:
            super().__delitem__(key)

    def pop(self, key, default):
        &#34;&#34;&#34;If key is in the dictionary, remove it and return its value, else
        return default. If default is not given and key is not in the
        dictionary, a KeyError is raised.
        &#34;&#34;&#34;
        if not self.__locked__:
            return super().pop(key, default)
        return super().__getitem__(key)

    def clear(self):
        &#34;&#34;&#34;Remove all items from the dictionary.&#34;&#34;&#34;
        if not self.__locked__:
            super().clear()

    def popitem(self):
        &#34;&#34;&#34;Not implemented!&#34;&#34;&#34;
        raise NotImplementedError

    def update(self, other):
        &#34;&#34;&#34;Update the dictionary with the key/value pairs from other,
        overwriting existing keys. Return None.
        update() accepts either another dictionary object or an iterable of
        key/value pairs (as tuples or other iterables of length two). If
        keyword arguments are specified, the dictionary is then updated with
        those key/value pairs: d.update(red=1, blue=2).
        &#34;&#34;&#34;
        if not self.__locked__:
            super().update(other)

    def lock(self):
        &#34;&#34;&#34;Locks this application context for changes.&#34;&#34;&#34;
        self.__locked__ = True

    def fit_context(self):
        &#34;&#34;&#34;Returns a locked PdpApplicationContext object of a previous fit.&#34;&#34;&#34;
        return self._fit_context__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pdpipe.core.PdpApplicationContext.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all items from the dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Remove all items from the dictionary.&#34;&#34;&#34;
    if not self.__locked__:
        super().clear()</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdpApplicationContext.fit_context"><code class="name flex">
<span>def <span class="ident">fit_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a locked PdpApplicationContext object of a previous fit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_context(self):
    &#34;&#34;&#34;Returns a locked PdpApplicationContext object of a previous fit.&#34;&#34;&#34;
    return self._fit_context__</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdpApplicationContext.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Locks this application context for changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock(self):
    &#34;&#34;&#34;Locks this application context for changes.&#34;&#34;&#34;
    self.__locked__ = True</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdpApplicationContext.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, key, default)</span>
</code></dt>
<dd>
<div class="desc"><p>If key is in the dictionary, remove it and return its value, else
return default. If default is not given and key is not in the
dictionary, a KeyError is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, key, default):
    &#34;&#34;&#34;If key is in the dictionary, remove it and return its value, else
    return default. If default is not given and key is not in the
    dictionary, a KeyError is raised.
    &#34;&#34;&#34;
    if not self.__locked__:
        return super().pop(key, default)
    return super().__getitem__(key)</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdpApplicationContext.popitem"><code class="name flex">
<span>def <span class="ident">popitem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Not implemented!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popitem(self):
    &#34;&#34;&#34;Not implemented!&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="pdpipe.core.PdpApplicationContext.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the dictionary with the key/value pairs from other,
overwriting existing keys. Return None.
update() accepts either another dictionary object or an iterable of
key/value pairs (as tuples or other iterables of length two). If
keyword arguments are specified, the dictionary is then updated with
those key/value pairs: d.update(red=1, blue=2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, other):
    &#34;&#34;&#34;Update the dictionary with the key/value pairs from other,
    overwriting existing keys. Return None.
    update() accepts either another dictionary object or an iterable of
    key/value pairs (as tuples or other iterables of length two). If
    keyword arguments are specified, the dictionary is then updated with
    those key/value pairs: d.update(red=1, blue=2).
    &#34;&#34;&#34;
    if not self.__locked__:
        super().update(other)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#creating-pipeline-stages-that-operate-on-column-subsets">Creating pipeline stages that operate on column subsets</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdpipe" href="index.html">pdpipe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdpipe.core.make_pdpipeline" href="#pdpipe.core.make_pdpipeline">make_pdpipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdpipe.core.AdHocStage" href="#pdpipe.core.AdHocStage">AdHocStage</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.core.ColumnsBasedPipelineStage" href="#pdpipe.core.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></h4>
</li>
<li>
<h4><code><a title="pdpipe.core.PdPipeline" href="#pdpipe.core.PdPipeline">PdPipeline</a></code></h4>
<ul class="">
<li><code><a title="pdpipe.core.PdPipeline.fit" href="#pdpipe.core.PdPipeline.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.fit_transform" href="#pdpipe.core.PdPipeline.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.get_transformer" href="#pdpipe.core.PdPipeline.get_transformer">get_transformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.memory_report" href="#pdpipe.core.PdPipeline.memory_report">memory_report</a></code></li>
<li><code><a title="pdpipe.core.PdPipeline.transform" href="#pdpipe.core.PdPipeline.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdpipe.core.PdPipelineStage" href="#pdpipe.core.PdPipelineStage">PdPipelineStage</a></code></h4>
<ul class="">
<li><code><a title="pdpipe.core.PdPipelineStage.AdHocStage" href="#pdpipe.core.PdPipelineStage.AdHocStage">AdHocStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.AggByCols" href="#pdpipe.core.PdPipelineStage.AggByCols">AggByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyByCols" href="#pdpipe.core.PdPipelineStage.ApplyByCols">ApplyByCols</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ApplyToRows" href="#pdpipe.core.PdPipelineStage.ApplyToRows">ApplyToRows</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Bin" href="#pdpipe.core.PdPipelineStage.Bin">Bin</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColByFrameFunc" href="#pdpipe.core.PdPipelineStage.ColByFrameFunc">ColByFrameFunc</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColDrop" href="#pdpipe.core.PdPipelineStage.ColDrop">ColDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColRename" href="#pdpipe.core.PdPipelineStage.ColRename">ColRename</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColReorder" href="#pdpipe.core.PdPipelineStage.ColReorder">ColReorder</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer" href="#pdpipe.core.PdPipelineStage.ColumnDtypeEnforcer">ColumnDtypeEnforcer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnTransformer" href="#pdpipe.core.PdPipelineStage.ColumnTransformer">ColumnTransformer</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage" href="#pdpipe.core.PdPipelineStage.ColumnsBasedPipelineStage">ColumnsBasedPipelineStage</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ConditionValidator" href="#pdpipe.core.PdPipelineStage.ConditionValidator">ConditionValidator</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropDuplicates" href="#pdpipe.core.PdPipelineStage.DropDuplicates">DropDuplicates</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropNa" href="#pdpipe.core.PdPipelineStage.DropNa">DropNa</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropRareTokens" href="#pdpipe.core.PdPipelineStage.DropRareTokens">DropRareTokens</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByLength" href="#pdpipe.core.PdPipelineStage.DropTokensByLength">DropTokensByLength</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.DropTokensByList" href="#pdpipe.core.PdPipelineStage.DropTokensByList">DropTokensByList</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Encode" href="#pdpipe.core.PdPipelineStage.Encode">Encode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FitOnly" href="#pdpipe.core.PdPipelineStage.FitOnly">FitOnly</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.FreqDrop" href="#pdpipe.core.PdPipelineStage.FreqDrop">FreqDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Log" href="#pdpipe.core.PdPipelineStage.Log">Log</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.MapColVals" href="#pdpipe.core.PdPipelineStage.MapColVals">MapColVals</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.OneHotEncode" href="#pdpipe.core.PdPipelineStage.OneHotEncode">OneHotEncode</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.PdPipeline" href="#pdpipe.core.PdPipelineStage.PdPipeline">PdPipeline</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RegexReplace" href="#pdpipe.core.PdPipelineStage.RegexReplace">RegexReplace</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RemoveStopwords" href="#pdpipe.core.PdPipelineStage.RemoveStopwords">RemoveStopwords</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.RowDrop" href="#pdpipe.core.PdPipelineStage.RowDrop">RowDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Scale" href="#pdpipe.core.PdPipelineStage.Scale">Scale</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.Schematize" href="#pdpipe.core.PdPipelineStage.Schematize">Schematize</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SetIndex" href="#pdpipe.core.PdPipelineStage.SetIndex">SetIndex</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.SnowballStem" href="#pdpipe.core.PdPipelineStage.SnowballStem">SnowballStem</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists" href="#pdpipe.core.PdPipelineStage.TfidfVectorizeTokenLists">TfidfVectorizeTokenLists</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.TokenizeText" href="#pdpipe.core.PdPipelineStage.TokenizeText">TokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.UntokenizeText" href="#pdpipe.core.PdPipelineStage.UntokenizeText">UntokenizeText</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValDrop" href="#pdpipe.core.PdPipelineStage.ValDrop">ValDrop</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.ValKeep" href="#pdpipe.core.PdPipelineStage.ValKeep">ValKeep</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.apply" href="#pdpipe.core.PdPipelineStage.apply">apply</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.description" href="#pdpipe.core.PdPipelineStage.description">description</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit" href="#pdpipe.core.PdPipelineStage.fit">fit</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.fit_transform" href="#pdpipe.core.PdPipelineStage.fit_transform">fit_transform</a></code></li>
<li><code><a title="pdpipe.core.PdPipelineStage.transform" href="#pdpipe.core.PdPipelineStage.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pdpipe.core.PdpApplicationContext" href="#pdpipe.core.PdpApplicationContext">PdpApplicationContext</a></code></h4>
<ul class="two-column">
<li><code><a title="pdpipe.core.PdpApplicationContext.clear" href="#pdpipe.core.PdpApplicationContext.clear">clear</a></code></li>
<li><code><a title="pdpipe.core.PdpApplicationContext.fit_context" href="#pdpipe.core.PdpApplicationContext.fit_context">fit_context</a></code></li>
<li><code><a title="pdpipe.core.PdpApplicationContext.lock" href="#pdpipe.core.PdpApplicationContext.lock">lock</a></code></li>
<li><code><a title="pdpipe.core.PdpApplicationContext.pop" href="#pdpipe.core.PdpApplicationContext.pop">pop</a></code></li>
<li><code><a title="pdpipe.core.PdpApplicationContext.popitem" href="#pdpipe.core.PdpApplicationContext.popitem">popitem</a></code></li>
<li><code><a title="pdpipe.core.PdpApplicationContext.update" href="#pdpipe.core.PdpApplicationContext.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>